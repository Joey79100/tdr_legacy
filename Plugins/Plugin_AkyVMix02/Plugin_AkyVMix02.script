<START_CONSTANTS>
PARAM_VAR_MASTER: 1 ;Used with Parameters command.>This "variable master" is an "ultimate tool" (controlled in F587 and C114 triggers) if Paolone's Local Long Alfa, Global Short Beta1 etc. numerical variables and their triggers are just not enough and/or seeming complex for your game.>>What does variable master do? - Well:>It has 50 new local variables and 50 new global variables - from now on each new variables will be called shortly "nvar". "New" means they have nothing to do with Paolone's "old" Local Long Alfa, Global Short Beta1 etc. variables. "Local" and "global" means the same as in the case of Paolone's variables: the "global" ones will keep their values even between the levels (but losing them in the title or for a new game), but the "local" ones will keep their values - even if you will come back to that level - only in their own levels.>>With nvars, you can:>- perform different mathematical operations,>- set/modify/check the values of nvars, "old" variables and memory zone fields.>- handle even floating values. (5 of 50 local nvars and 5 of 50 global nvars can do that.)>>Size limit for these variables/memory zones (i.e. the minimum and the maximum number in it):>New variables:>- integer: from -2 147 483 648 to 2 147 483 647>- floating: (theoretically these can be really huge values, but, for technical reasons I don't recommend a floating value out of the "from -2 147 482.000 to 2 147 482.000" interval) >Old variables (all integers):>- Current Value, Last Input Number, Global/Local Long Timer, Global/Local Long Alfa/Beta/Delta: from -2 147 483 648 to 2 147 483 647>- Global/Local Short Alfa/Beta/Delta: from -32 768 to 32 767>- Global/Local Short Alfa/Beta/Delta: from 0 to 255>Memory zone fields (all integers):>- Byte: from 0 to 255>- Short: from -32 768 to 32 767>- Long: from -2 147 483 648 to 2 147 483 647>>Syntax: Parameters=PARAM_VAR_MASTER, IdParamList, Operation, SrcType, SrcValue, Float, SrcSubject, SrcAnim, TrgType, TrgValue, TrgSubject, TrgAnim, Extra>>As opposed to the "old" variables of Paolone, nvars are no overlapped with each other, you can use freely any nvar, whatever else other nvar is also used! (Check Paolone's variable tutorial to understand where old variables can be overlapped.)>>Important!>- Nvars naturally also keep their values saved in savegames.>- Local nvars (just like Paolone's local variables) will lose their values if you come back to their levels - but with ResetHUB.>- Some global nvars will keep their values even in the title, so you can transport data>>a, from a level into the title, when the game ends/Lara dies/or you choose on "Exit to Title", or>b, from the title into a level, when you start a New Game.>>These "data-kept-in-title" variables are:>>a, Global Int Nvar41, 42, 43, 44, 45 and>b, Global Float Nvar4, 5.>>But that doesn't mean these global nvars also keep the values in title, from the previous launch of the game, if you restart tomb4.exe the next time, reaching the title! >>Examples>-------->>A, Executable (F587):>>Set -238 integer value in Global Short Alfa1 variable:>Parameters= PARAM_VAR_MASTER, 1, NVAR_OPR_SET, NVAR_TPE_NMB, -238, IGNORE, IGNORE, IGNORE, NVAR_TPE_GSA, 1, IGNORE, IGNORE, IGNORE>>Add 7.824 floating value to the actual value of Local Float Nvar3 variable:>Parameters= PARAM_VAR_MASTER, 2, NVAR_OPR_ADD, NVAR_TPE_NMB, 7, 824, IGNORE, IGNORE, NVAR_TPE_LFN, 3, IGNORE, IGNORE, IGNORE>>Subtract the actual value of Global Long Beta variable from the actual value of Local Int Nvar27 variable:>Parameters= PARAM_VAR_MASTER, 3, NVAR_OPR_SUB, NVAR_TPE_GLB, IGNORE, IGNORE, IGNORE, IGNORE, NVAR_TPE_LIN, 27, IGNORE, IGNORE, IGNORE>>Multiply the actual value of Global Float Nvar5 variable by "Pi" (3.14 this time):>Parameters= PARAM_VAR_MASTER, 4, NVAR_OPR_MLT, NVAR_TPE_NMB, 3, 140, IGNORE, IGNORE, NVAR_TPE_GFN, 5, IGNORE, IGNORE, IGNORE>>Divide the actual value of Global Int Nvar19 variable by the actual value of Global Int Nvar18 variable, keeping the remainder in Global Int Nvar40 variable:>Parameters= PARAM_VAR_MASTER, 5, NVAR_OPR_DIV, NVAR_TPE_GIN, 18, IGNORE, IGNORE, IGNORE, NVAR_TPE_GIN, 19, IGNORE, IGNORE, FNVAR_EXTRA_REMAINDER>>Raise the actual value of Global Float Nvar2 variable to the power stored as the actual value of Local Byte Alfa1 variable:>Parameters= PARAM_VAR_MASTER, 6, NVAR_OPR_POW, NVAR_TPE_LBA, 1, IGNORE, IGNORE, IGNORE, NVAR_TPE_GFN, 2, IGNORE, IGNORE, IGNORE>>Calculate the square root of the actual value of "Inventory. Ammo Poisoned CrossBow (Short)" Savegame Memory Zone field (Field ID70):>Parameters= PARAM_VAR_MASTER, 7, NVAR_OPR_SQR, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE, NVAR_TPE_GMZ, 70, IGNORE, IGNORE, IGNORE>>Turn the sign of the actual value of "Custom_A (Different usage in according with type of item) (Short)" Item Memory Zone field of object having Index174 in the map (Field ID21):>Parameters= PARAM_VAR_MASTER, 8, NVAR_OPR_MLT, NVAR_TPE_NMB, -1, IGNORE, IGNORE, IGNORE, NVAR_TPE_OMZ, 21, 174, IGNORE, IGNORE>>Set the actual value of Local Byte Delta1 variable in "Speed Layer2 (4th field of Layer2= script command) (Byte)" Code Memory Zone field (Field ID20):>Parameters= PARAM_VAR_MASTER, 9, NVAR_OPR_SET, NVAR_TPE_LBD, 1, IGNORE, IGNORE, IGNORE, NVAR_TPE_CMZ, 20, IGNORE, IGNORE, IGNORE>>Set the actual value of "Speed (Short)" Animation Memory Zone field (Field ID4) of Lara's Animation450 of LARA slot (Slot ID0) in the same field of Animation452, of the same slot:>Parameters= PARAM_VAR_MASTER, 10, NVAR_OPR_SET, NVAR_TPE_AMZ, 4, IGNORE, 0, 450, NVAR_TPE_AMZ, 4, 0, 452, IGNORE>>Add the actual value of Local Int Nvar7 variable to the actual value of "Distance to enable the MIP version (Short)" Slot Memory Zone field of BADDY_1 slot (Slot ID41) (Field ID8):>Parameters= PARAM_VAR_MASTER, 11, NVAR_OPR_ADD, NVAR_TPE_LIN, 7, IGNORE, IGNORE, IGNORE, NVAR_TPE_SMZ, 8, 41, IGNORE, IGNORE>>Subtract the actual value of "Y Facing about the cam view on Y Axis (Short)" Inventory Memory Zone field (Field ID4) of the big medipack (Inventory ID20) from the actual value of Last Input Number variable:>Parameters= PARAM_VAR_MASTER, 12, NVAR_OPR_SUB, NVAR_TPE_IMZ, 4, IGNORE, 20, IGNORE, NVAR_TPE_INP, IGNORE, IGNORE, IGNORE, IGNORE>>Turn the value of Local Int Nvar1 variable back to 0 default value:>Parameters= PARAM_VAR_MASTER, 13, NVAR_OPR_SET, NVAR_TPE_NMB, 0, IGNORE, IGNORE, IGNORE, NVAR_TPE_LIN, 1, IGNORE, IGNORE, IGNORE>>Set Bit 5 in Local Int Nvar10 variable:>Parameters= PARAM_VAR_MASTER, 14, NVAR_OPR_BIT, NVAR_TPE_NMB, 5, IGNORE, IGNORE, IGNORE, NVAR_TPE_LIN, 10, IGNORE, IGNORE, IGNORE>>Set a random number (generated between the minimum value in Global Int Nvar38 and the maximum value in Global Int Nvar39) in Global Int Nvar37 variable:>Parameters= PARAM_VAR_MASTER, 15, NVAR_OPR_RND, IGNORE, 38, 39, IGNORE, IGNORE, NVAR_TPE_GIN, 37, IGNORE, IGNORE, IGNORE>>B, Condition (C114):>>The actual value of Local Int Nvar12 variable is bigger than the actual value of Local Int Nvar15 variable.>Parameters= PARAM_VAR_MASTER, 16, NVAR_OPR_BIG, NVAR_TPE_LIN, 15, IGNORE, IGNORE, IGNORE, NVAR_TPE_LIN, 12, IGNORE, IGNORE, IGNORE>>The actual value of "Distance to enable the MIP version (Short)" Slot Memory Zone field of BADDY_1 slot (Slot ID41) (Field ID8) is equal with the actual value of Global Int Nvar22 variable.>Parameters= PARAM_VAR_MASTER, 17, NVAR_OPR_EQL, NVAR_TPE_GIN, 22, IGNORE, IGNORE, IGNORE, NVAR_TPE_SMZ, 8, 41, IGNORE, IGNORE>>The actual value of "Speed Layer2 (4th field of Layer2= script command) (Byte)" Code Memory Zone field (Field ID20) is smaller than 7.>Parameters= PARAM_VAR_MASTER, 18, NVAR_OPR_SML, NVAR_TPE_NMB, 7, IGNORE, IGNORE, IGNORE,  NVAR_TPE_CMZ, 20, IGNORE, IGNORE, IGNORE>>Check if Bit 20 is set in Local Int Nvar12 variable:>Parameters= PARAM_VAR_MASTER, 19, NVAR_OPR_BIT, NVAR_TPE_NMB, 220, IGNORE, IGNORE, IGNORE, NVAR_TPE_LIN, 12, IGNORE, IGNORE, IGNORE>>IdParamList field>----------------->This is a progressive number to identify this "Parameters=PARAM_VAR_MASTER" command script in trigger window of ngle.>You'll type 1, for your first PARAM_VAR_MASTER command, 2 for second etc.>>Operation field>--------------->Choose the proper NVAR_OPR constant for the required operation.>>Important!>1. Don't be surprised if you got out of the limit, so the solution will not be proper.>For example, 130 divided by 50 in an integer variable should be 2.60, but it is integer, so the result will be 2.00.>Or, a memory zone field with "byte" size cannot handle a number above 255, a bigger number forced here will end up in a strange value as the solution.>Or, animation field values of Animation Memory Zone can be overwritten probably only in the case of Lara, other animations seem only readable here.>Etc.>2. Operations with floating numbers can be a bit inaccurate under some (unknown?) circumstances. (But having the same result, executing it any times.) So you should always check these operation values in the diagnostic screen or in the log.>The issue will be detected probably only in the floating part, after the floating point, showing up probably only in the last, third digit, probably only as a +/-1 difference, i.e. it is a very tiny error - perhaps this difference is not important for your purpose.>>SrcType field>-------------->Choose the proper NVAR_TPE constant for the required source type of the operation.>>Type IGNORE (-1) if the operation is about square root or random number.>>SrcValue field>-------------->In the case of nvars, type an ID here:>>a, global/local (integer) variables: numbers from 1 to 45 means Variable ID1, Variable ID2,... Variable ID44, Variable ID45.>b, global/local (floating) variables: numbers from 1 to 5 means Variable ID1, Variable ID2, Variable ID3, Variable ID4, Variable ID5.>>The actual value of that variable will be the source value.>>In the case of old variables, type an ID here:>>a, IGNORE (-1), if it is a variable without an ID number (like Local Long Alfa or Current Value etc.).>b, 1 or 2, for Short1 or Short2 variables.>c, from 1 to 4, for Byte1, Byte2, Byte3, Byte4 variables.>>The actual value of that variable will be the source value.>>In the case of memory zone fields, type an ID here:>See different classic trng.dll triggers. For example, F262 has the table of Savegame Memory Zone fields. If you want eg. "Statistics. Used Ammos (Short)" field, then you can see (clicking on the P button next to Timer window) that it has ID76 - that 76 is what you need to type here now.>The actual value of that field will be the source value.>>In the case of pure integer number sources (or, for the integer part, in the case of floating number sources) - i.e. if the number is not the value of a variable/memory zone field:>Type a value here, between -32768 and 32767, that will be the source value.>>In the case of random generators, type the ID of a Global Int Nvar here. The actual value of that variable will be the minimum value for the random interval.>>Type IGNORE (-1) if the operation is about square root or random number.>>Notes:>- As you can see, the value limits are between -32768 and 32767 with pure numbers. If your purpose is a bigger number here with pure numbers, then the trick is this:>For example, you want to set Value 100 000 in a target "long" variable. Then first set 20 000 there. Then, use another PARAM_VAR_MASTER command, in which you will multiply that Value 20 000 by 5, for the required Value 100 000.>Or, for example, you want to set Value 40 000 in a target "long" variable. Then first set 30 000 there. Then, use another PARAM_VAR_MASTER command, in which you will add 10 000 to that Value 30 000, for the required Value 40 000.>- Excepting square root or old variables without ID, -1 will never be read as "IGNORE" now.>- If you only want to turn the sign of the target (eg. from -6 to +6 or vice verse), then the proper operation for this is "multiplied by -1", because eg. -6 × -1 = +6.>>Float field>----------->Type the floating value here (for three digits) if the SrcType field value is about pure floating number sources.>>A few examples to handle pure number sources:>SrcValue field (152 typed) and Float field (703 typed for 703) is 152.703 floating value.>SrcValue field (-6 typed) and Float field (-48 typed for 048) is -6.048 floating value.>SrcValue field (0 typed) and Float field (2 typed for 002) is 0.002 floating value.>SrcValue field (19 typed) and Float field (IGNORE typed for 000) is 19.000 integer value.>>In the case of random generators, type the ID of a Global Int Nvar here. The actual (not floating!) value of that variable will be the maximum value for the random interval.>>Type IGNORE (-1) in other cases.>>SrcSubject field>---------------->If the source is a Slot, Item, Inventory or Animation Memory Zone field, then you need to type the subject ID of that field here:>>Slot ID: see the ID numbers of Moveable object slots in NG Center/Reference.>Item ID: type here the ID of the object you can see in the map.>Inventory ID: see eg. trng.dll F335 for the inventory item ID's (clicking on the P button next to Timer window).>>In the case of animations, type here the slot ID, whereto the animation (see SrcAnim field) belongs.>>Type IGNORE (-1) in other cases.>>SrcAnim field>------------->In the case of Animation Memory Zone field sources, type the animation ID here.>>Type IGNORE (-1) in other cases.>>TrgType field>------------->Choose the proper NVAR_TPE constant for the required target type of the operation.>>TrgValue field>-------------->In the case of nvars, type an ID here:>>a, global/local (integer) variables: numbers from 1 to 45 means Variable ID1, Variable ID2,... Variable ID44, Variable ID45.>b, global/local (floating) variables: numbers from 1 to 5 means Variable ID1, Variable ID2, Variable ID3, Variable ID4, Variable ID5.>>The actual value of that variable will be the target value that needs to be overwritten.>>In the case of old variables, type an ID here:>>a, IGNORE (-1), if it is a variable without an ID number (like Local Long Alfa or Current Value etc.).>b, 1 or 2, for Short1 or Short2 variables.>c, from 1 to 4, for Byte1, Byte2, Byte3, Byte4 variables.>>The actual value of that variable will be the target value that needs to be overwritten.>>In the case of memory zone fields, type an ID here:>See different classic trng.dll triggers. For example, F262 has the table of Savegame Memory Zone fields. If you want eg. "Statistics. Used Ammos (Short)" field, then you can see that it has ID76 - that 76 is what you need to type here now.>The actual value of that field will be the target value that needs to be overwritten.>>TrgSubject field>---------------->If the target is a Slot, Item, Inventory or Animation Memory Zone field, then you need to type the subject ID of that field here.>>Slot ID: see the ID numbers of Moveable object slots in NG Center/Reference.>Item ID: type here the ID of the object you can see in the map.>Inventory ID: see eg. trng.dll F335 for the inventory item ID's.>>In the case of animations, type here the slot ID, whereto the animation (see TrgAnim field) belongs.>>Type IGNORE (-1) in other cases.>>TrgAnim field>------------->In the case of Animation Memory Zone field target, type the animation ID here.>>Type IGNORE (-1) in other cases.>>Note:>I think workable target animations to modify belong to only the different Lara objects.>>Extra field>----------->Extra features can be added to the operation here with FNVAR_EXTRA flags.>>Type IGNORE (-1) if you don't need an extra feature.

NVAR_OPR_SET:1; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to copy the source value into the target, overwriting the previous value of the target, keeping the source value.>>Note:>If you want to remove the floating numbers after the floating point, to transform the number into integer, then just copy the floating number into an integer variable/field.

NVAR_OPR_ADD:2; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to add the source value to the target value, overwriting the previous value of the target, keeping the source value.

NVAR_OPR_SUB:3; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to subtract the source value from the target value, overwriting the previous value of the target, keeping the source value.

NVAR_OPR_MLT:4; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to multiply the target value by the source value, overwriting the previous value of the target, keeping the source value.

NVAR_OPR_DIV:5; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to divide the target value by the source value, overwriting the previous value of the target, keeping the source value.

NVAR_OPR_POW:6; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to raise the target to the power of the source value, overwriting the previous value of the target, keeping the source value.>>Note:>Probably the operation works well only if the number you raise is in a floating variable. (In the case if it should be an integer number, it means there should be a pure 0 after the floating point, so, for example, 15 should be 15.000.) The power number could be either integer or floating.>However, feel free to test with raising integer numbers to integer power, but this version perhaps is only theoretical here.

NVAR_OPR_SQR:7; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want the square root of the target, overwriting the previous value of the target.

NVAR_OPR_BIG:8; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to check if the target value is bigger than the source value.

NVAR_OPR_BOE:9; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to check if the target value is bigger than the source value, or equal with it.

NVAR_OPR_SML:10; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to check if the target value is smaller than the source value.

NVAR_OPR_SOE:11; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to check if the target value is smaller than the source value, or equal with it.

NVAR_OPR_EQL:12; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to check if the target value is equal with the source value.

NVAR_OPR_BIT:13; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to set or clear a bit (of the source value) in the target value (from Bit 0 to Bit 30), overwriting the previous value of the target, keeping the source value.>Also use this if you want to check if the target value has the bit (of the source value) set.>>Source value, not adding anything: this bit will be set (if it is just clear there) in the target value. (Eg. type 5 for Bit 5.)>Source value, adding 100: this bit will be cleared (if it is just set there) in the target value. (Eg. type 105 for Bit 5.)>Source value, adding 200: this bit will be checked if it is just set there, in the target value. (Eg. type 205 for Bit 5.)>>Floating or negative target values cannot use this operation.

NVAR_OPR_RND:14; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want to set a random integer number in the target value, overwriting the previous value of the target.>>The random value will be generated between a minimum and a maximum value:>- The minimum value, between -2 147 483 648 and 2 147 483 647, always reading it from SrcValue field.>- The maximum value, between -2 147 483 648 and 2 147 483 647, always reading it from Float field.>>The minimum and maximum values themselves are also included in the interval.>>Important!>The difference between the minimum and the maximum value cannot be bigger than 32767. The difference will be calculated from the minimum value, bigger values than the calculated upper limit (=minimum+32767) will be ignored, even if they are below the maximum value.>If you want a bigger interval than 32767, then you need to multiply the result.

NVAR_TPE_LIN:1; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a new variable (nvar) to be the source/target type of the operation, as a local integer variable (Local Int Nvar).

NVAR_TPE_GIN:2; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a new variable (nvar) to be the source/target type of the operation, as a global integer variable (Global Int Nvar).

NVAR_TPE_LFN:3; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a new variable (nvar) to be the source/target type of the operation, as a local floating variable (Local Float Nvar).

NVAR_TPE_GFN:4; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a new variable (nvar) to be the source/target type of the operation, as a global floating variable (Global Float Nvar).

NVAR_TPE_LLA:5; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want Local Long Alfa "old" variable to be the source/target type of the operation.

NVAR_TPE_LSA:6; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Local Short Alfa "old" variable to be the source/target type of the operation.

NVAR_TPE_LBA:7; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Local Byte Alfa "old" variable to be the source/target type of the operation.

NVAR_TPE_LLB:8; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want Local Long Beta "old" variable to be the source/target type of the operation.

NVAR_TPE_LSB:9; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Local Short Beta "old" variable to be the source/target type of the operation.

NVAR_TPE_LBB:10; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Local Byte Beta "old" variable to be the source/target type of the operation.

NVAR_TPE_LLD:11; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want Local Long Delta "old" variable to be the source/target type of the operation.

NVAR_TPE_LSD:12; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Local Short Delta "old" variable to be the source/target type of the operation.

NVAR_TPE_LBD:13; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Local Byte Delta "old" variable to be the source/target type of the operation.

NVAR_TPE_GLA:14; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want Global Long Alfa "old" variable to be the source/target type of the operation.

NVAR_TPE_GSA:15; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Global Short Alfa "old" variable to be the source/target type of the operation.

NVAR_TPE_GBA:16; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Global Byte Alfa "old" variable to be the source/target type of the operation.

NVAR_TPE_GLB:17; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want Global Long Beta "old" variable to be the source/target type of the operation.

NVAR_TPE_GSB:18; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Global Short Beta "old" variable to be the source/target type of the operation.

NVAR_TPE_GBB:19; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Global Byte Beta "old" variable to be the source/target type of the operation.

NVAR_TPE_GLD:20; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want Global Long Delta "old" variable to be the source/target type of the operation.

NVAR_TPE_GSD:21; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Global Short Delta "old" variable to be the source/target type of the operation.

NVAR_TPE_GBD:22; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a Global Byte Delta "old" variable to be the source/target type of the operation.

NVAR_TPE_OMZ:23; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want an item (object) memory zone field to be the source/target type of the operation.

NVAR_TPE_IMZ:24; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want an inventory memory zone field to be the source/target type of the operation.

NVAR_TPE_GMZ:25; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want an savegame memory zone field to be the source/target type of the operation.

NVAR_TPE_SMZ:26; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want an slot memory zone field to be the source/target type of the operation.

NVAR_TPE_CMZ:27; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a code memory zone field to be the source/target type of the operation.

NVAR_TPE_AMZ:28; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want an animation memory zone field to be the source/target type of the operation.

NVAR_TPE_NMB:29; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want a pure integer/floating number ("pure" means it is not the actual value of a variable or a memory zone field) to be the source type of the operation. - But this cannot be the target type of the operation!

NVAR_TPE_CUV:30; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want Current Variable "old" variable to be the source/target type of the operation.

NVAR_TPE_LLT:31; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want Local Long Timer "old" variable to be the source/target type of the operation.

NVAR_TPE_GLT:32; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want Global Long Timer "old" variable to be the source/target type of the operation.

NVAR_TPE_INP:33; Used with Parameters=PARAM_VAR_MASTER command.>This flag is needed if you want Last Input Number "old" variable to be the source/target type of the operation.

FNVAR_EXTRA_REMAINDER:$0001; Used with Parameters=PARAM_VAR_MASTER command.>If the operation is division, and you add this flag, then the remainder of the division will be copied into Global Int Nvar40 variable.>For example, if the division is 16/5, then the solution is 3.2, which is 3 as an integer. 3×5 is 15, 16-15=1, so the remainder of this division is 1.>>Notes:>- If either the source or the target value is floating, then only the integer part will be calculated for the remainder. (For example, in the case of 16.52/5, the remainder is 1, as if the operation were 16/5.) - Even if we copied it into a Float variable instead of an Int one, during the operation.>- If you don't want the remainder in this variable, then just simply copy it with a NVAR_OPR_SET operation into another variable after the division.

PARAM_DIAGNOSTIC: 2 ;Used with Parameters command.>You need this in F588 triggers if you want to see diagnostic data on the screen for the new variables (see F587) or the memory zone fields.>>Syntax: Parameters=PARAM_DIAGNOSTIC, IdParamList, Position, Size, SpaceH, SpaceV, Color, NewInteger, SaveGame, Item, LittleGroup, Bit, Extra1, Extra2>>Notes:>- You don't need DIAGNOSTIC or DIAGNOSTICTYPE Script commands.>- The subject of item/inventory/slot/animation memory zone fields in this diagnostic will be the Moveable object/inventory item/Moveable object slot/animation that is the actual subject of those zones.>If you change the subject while the diagnostic about that subject is being shown on the screen, then the diagnostic data will be refreshed immediately for the new subject on the screen.>- If the slot ID+relative animation ID data of the absolute animation ID (which is the actual subject of the animation memory zone) is wrong, then the reason is that there is a slot (with smaller ID than the real slot) in the WAD without any animation. (Like CROWBAR_ANIM, GUNSHELL or SHOTGUNSHELL, but in those cases this bug has been found and fixed.)>>IdParamList field>----------------->This is a progressive number to identify this "Parameters=PARAM_DIAGNOSTIC" command script in trigger window of ngle.>You'll type 1, for your first PARAM_DIAGNOSTIC command, 2 for second etc.>>Position field>-------------->Choose the proper FDGN_POS flag for the position.>>Size field>---------->Type the value for the required character size:>>1 - little (absolute)>2 - little (relative, related to the actual font size)>3 - normal (the actual font size)>4 - big (relative, related to the actual font size)>>SpaceH field>------------>The horizontal distance between the first character of the ID/name of the variable/memory zone field and the first character of the value of that variable/memory zone field, in pixels.>(In the case of bits: the horizontal distance of the starts of rows from the left edge of the screen.)>>SpaceV field>------------>The vertical distance between the rows, in pixels.>>Color field>----------->Choose a classic trng.dll CL_... constant for the character color.>>NewInteger field>---------------->Type a FDGN_NINT flag here if you want to see some new integer variable in the diagnostic.>Add them to each other with Sign + if you want to see more groups of them.>Type IGNORE (-1) if you don't want new integer variables.>>SaveGame field>-------------->Type a FDGN_SVGM flag here if you want to see some savegame memory zone field in the diagnostic.>Add them to each other with Sign + if you want to see more groups of them.>Type IGNORE (-1) if you don't want savegame memory zone fields.>>Item field>---------->Type a FDGN_ITEM flag here if you want to see some item memory zone field in the diagnostic.>Add them to each other with Sign + if you want to see more groups of them.>Type IGNORE (-1) if you don't want item memory zone fields.>>LittleGroup field>----------------->Type a FDGN_LTLE flag here if you want to see some little group (new floating variables, inventory/code/slot/animation memory zone fields) in the diagnostic.>Add them to each other with Sign + if you want to see more groups of them.>Type IGNORE (-1) if you don't want those little groups.>>Bit field>--------->Open F589 trigger in Set Trigger Type panel in NGLE. Click on the P button next to the Timer window, to see the ID values of new variables in the TXT that opens. Type an ID of them in this field, to see in this diagnostic if that variable has just set or clear a bit.>>Type IGNORE (-1) if you don't want to check the bits in a value.>>Important!>Never check a variable with negative value or a floating variable here.>>Extra1 field>------------>A field for data shown on the screen, defined only later, in an update of this plugin.>Now type IGNORE (-1).>>Extra2 field>------------>A field for data shown on the screen, defined only later, in an update of this plugin.>Now type IGNORE (-1).

FDGN_POS_TOP:1; Used with Parameters=PARAM_DIAGNOSTIC command.>The diagnostic will be printed on the top of the screen.

FDGN_POS_UP:2; Used with Parameters=PARAM_DIAGNOSTIC command.>The diagnostic will be printed on the upper half of the screen, but below the top.

FDGN_POS_MIDDLE:3; Used with Parameters=PARAM_DIAGNOSTIC command.>The diagnostic will be printed on the middle of the screen.

FDGN_POS_DOWN:4; Used with Parameters=PARAM_DIAGNOSTIC command.>The diagnostic will be printed on the lower half of the screen.

FDGN_NINT_ALL:$0001; Used with Parameters=PARAM_DIAGNOSTIC command.>All the new integer variables (Global Int Nvar1-45, Local Int Nvar1-45) will be printed.

FDGN_NINT_GLOBAL:$0002; Used with Parameters=PARAM_DIAGNOSTIC command.>All the new global integer variables (Global Int Nvar1-45) will be printed.

FDGN_NINT_LOCAL:$0004; Used with Parameters=PARAM_DIAGNOSTIC command.>All the new local integer variables (Local Int Nvar1-45) will be printed.

FDGN_NINT_GLOB_FH:$0008; Used with Parameters=PARAM_DIAGNOSTIC command.>The first half of the new global integer variables (Global Int Nvar1-23) will be printed.

FDGN_NINT_GLOB_SH:$0010; Used with Parameters=PARAM_DIAGNOSTIC command.>The second half of the new global integer variables (Global Int Nvar24-45) will be printed.

FDGN_NINT_LOC_FH:$0020; Used with Parameters=PARAM_DIAGNOSTIC command.>The first half of the new local integer variables (Local Int Nvar1-23) will be printed.

FDGN_NINT_LOC_SH:$0040; Used with Parameters=PARAM_DIAGNOSTIC command.>The second half of the new local integer variables (Local Int Nvar24-45) will be printed.

FDGN_NINT_GLOB_12:$0080; Used with Parameters=PARAM_DIAGNOSTIC command.>The new global integer variables from 1 to 12 (Global Int Nvar1-12) will be printed.

FDGN_NINT_GLOB_23:$0100; Used with Parameters=PARAM_DIAGNOSTIC command.>The new global integer variables from 13 to 23 (Global Int Nvar13-23) will be printed.

FDGN_NINT_GLOB_34:$0200; Used with Parameters=PARAM_DIAGNOSTIC command.>The new global integer variables from 24 to 34 (Global Int Nvar24-34) will be printed.

FDGN_NINT_GLOB_45:$0400; Used with Parameters=PARAM_DIAGNOSTIC command.>The new global integer variables from 35 to 45 (Global Int Nvar35-45) will be printed.

FDGN_NINT_LOC_12:$0800; Used with Parameters=PARAM_DIAGNOSTIC command.>The new local integer variables from 1 to 12 (Local Int Nvar1-12) will be printed.

FDGN_NINT_LOC_23:$1000; Used with Parameters=PARAM_DIAGNOSTIC command.>The new local integer variables from 13 to 23 (Local Int Nvar13-23) will be printed.

FDGN_NINT_LOC_34:$2000; Used with Parameters=PARAM_DIAGNOSTIC command.>The new local integer variables from 24 to 34 (Local Int Nvar24-34) will be printed.

FDGN_NINT_LOC_45:$4000; Used with Parameters=PARAM_DIAGNOSTIC command.>The new local integer variables from 35 to 45 (Local Int Nvar35-45) will be printed.

FDGN_SVGM_ALL:$0001; Used with Parameters=PARAM_DIAGNOSTIC command.>All the savegame memory zone fields (Field ID from 0 to 93) will be printed.

FDGN_SVGM_FH:$0002; Used with Parameters=PARAM_DIAGNOSTIC command.>The first half of the savegame memory zone fields (Field ID from 0 to 46) will be printed.

FDGN_SVGM_SH:$0004; Used with Parameters=PARAM_DIAGNOSTIC command.>The second half of the savegame memory zone fields (Field ID from 47 to 93) will be printed.

FDGN_SVGM_1Q:$0008; Used with Parameters=PARAM_DIAGNOSTIC command.>The first quarter of the savegame memory zone fields (Field ID from 0 to 23) will be printed.

FDGN_SVGM_2Q:$0010; Used with Parameters=PARAM_DIAGNOSTIC command.>The second quarter of the savegame memory zone fields (Field ID from 24 to 46) will be printed.

FDGN_SVGM_3Q:$0020; Used with Parameters=PARAM_DIAGNOSTIC command.>The third quarter of the savegame memory zone fields (Field ID from 47 to 70) will be printed.

FDGN_SVGM_4Q:$0040; Used with Parameters=PARAM_DIAGNOSTIC command.>The fourth quarter of the savegame memory zone fields (Field ID from 71 to 93) will be printed.

FDGN_SVGM_11:$0080; Used with Parameters=PARAM_DIAGNOSTIC command.>The savegame memory zone fields from 0 to 11 (Field ID from 0 to 11) will be printed.

FDGN_SVGM_23:$0100; Used with Parameters=PARAM_DIAGNOSTIC command.>The savegame memory zone fields from 12 to 23 (Field ID from 12 to 23) will be printed.

FDGN_SVGM_35:$0200; Used with Parameters=PARAM_DIAGNOSTIC command.>The savegame memory zone fields from 24 to 35 (Field ID from 24 to 35) will be printed.

FDGN_SVGM_46:$0400; Used with Parameters=PARAM_DIAGNOSTIC command.>The savegame memory zone fields from 36 to 46 (Field ID from 36 to 46) will be printed.

FDGN_SVGM_58:$0800; Used with Parameters=PARAM_DIAGNOSTIC command.>The savegame memory zone fields from 47 to 58 (Field ID from 47 to 58) will be printed.

FDGN_SVGM_70:$1000; Used with Parameters=PARAM_DIAGNOSTIC command.>The savegame memory zone fields from 59 to 70 (Field ID from 59 to 70) will be printed.

FDGN_SVGM_82:$2000; Used with Parameters=PARAM_DIAGNOSTIC command.>The savegame memory zone fields from 71 to 82 (Field ID from 71 to 82) will be printed.

FDGN_SVGM_93:$4000; Used with Parameters=PARAM_DIAGNOSTIC command.>The savegame memory zone fields from 83 to 93 (Field ID from 83 to 93) will be printed.

FDGN_ITEM_ALL:$0001; Used with Parameters=PARAM_DIAGNOSTIC command.>All the item memory zone fields (Field ID from 0 to 39) will be printed.

FDGN_ITEM_FH:$0002; Used with Parameters=PARAM_DIAGNOSTIC command.>The first half of the item memory zone fields (Field ID from 0 to 19) will be printed.

FDGN_ITEM_SH:$0004; Used with Parameters=PARAM_DIAGNOSTIC command.>The second half of the item memory zone fields (Field ID from 20 to 39) will be printed.

FDGN_ITEM_09:$0008; Used with Parameters=PARAM_DIAGNOSTIC command.>The item memory zone fields from 0 to 9 (Field ID from 0 to 9) will be printed.

FDGN_ITEM_19:$0010; Used with Parameters=PARAM_DIAGNOSTIC command.>The item memory zone fields from 10 to 19 (Field ID from 10 to 19) will be printed.

FDGN_ITEM_29:$0020; Used with Parameters=PARAM_DIAGNOSTIC command.>The item memory zone fields from 20 to 29 (Field ID from 20 to 29) will be printed.

FDGN_ITEM_39:$0040; Used with Parameters=PARAM_DIAGNOSTIC command.>The item memory zone fields from 30 to 39 (Field ID from 30 to 39) will be printed.

FDGN_LTLE_NFLT:$0001; Used with Parameters=PARAM_DIAGNOSTIC command.>All the new (global and local) floating variables (Global/Local Float Nvar1-5) will be printed.

FDGN_LTLE_INVT:$0002; Used with Parameters=PARAM_DIAGNOSTIC command.>All the inventory memory zone fields (Field ID from 0 to 9) will be printed.

FDGN_LTLE_CODE_ALL:$0004; Used with Parameters=PARAM_DIAGNOSTIC command.>All the code memory zone fields (Field ID from 0 to 23) will be printed.

FDGN_LTLE_CODE_11:$0008; Used with Parameters=PARAM_DIAGNOSTIC command.>The code memory zone fields from 0 to 11 (Field ID from 0 to 11) will be printed.

FDGN_LTLE_CODE_23:$0010; Used with Parameters=PARAM_DIAGNOSTIC command.>The code memory zone fields from 12 to 23 (Field ID from 12 to 23) will be printed.

FDGN_LTLE_SLOT_ALL:$0020; Used with Parameters=PARAM_DIAGNOSTIC command.>All the slot memory zone fields (Field ID from 0 to 18) will be printed.

FDGN_LTLE_SLOT_09:$0040; Used with Parameters=PARAM_DIAGNOSTIC command.>The slot memory zone fields from 0 to 9 (Field ID from 0 to 9) will be printed.

FDGN_LTLE_SLOT_18:$0080; Used with Parameters=PARAM_DIAGNOSTIC command.>The slot memory zone fields from 10 to 18 (Field ID from 10 to 18) will be printed.

FDGN_LTLE_ANIM_ALL:$0100; Used with Parameters=PARAM_DIAGNOSTIC command.>All the animation memory zone fields (Field ID from 0 to 18) will be printed.

FDGN_LTLE_ANIM_09:$0200; Used with Parameters=PARAM_DIAGNOSTIC command.>The animation memory zone fields from 0 to 9 (Field ID from 0 to 9) will be printed.

FDGN_LTLE_ANIM_18:$0400; Used with Parameters=PARAM_DIAGNOSTIC command.>The animation memory zone fields from 10 to 18 (Field ID from 10 to 18) will be printed.

PARAM_PRINT_VAR: 3 ;Used with Parameters command.>You need this in F591 triggers if you want to print some custom text on the screen, with a new variable (see F587) or a memory zone field value in it.>>Syntax: Parameters=PARAM_PRINT_VAR, IdParamList, Case, PositionX, PositonY, Size, Color, Text, Value1, Value2, Value3>>Notes:>- Any printing feature of trng.dll has no effect on this print, and vice verse.>- The subject of item/inventory/slot/animation memory zone fields of this print will be the Moveable object/inventory item/Moveable object slot/animation that is the actual subject of those zones.>If you change the subject while the text is on the screen, then the data will be refreshed immediately for the new subject on the screen.>>IdParamList field>----------------->This is a progressive number to identify this "Parameters=PARAM_PRINT_VAR" command script in trigger window of ngle.>You'll type 1, for your first PARAM_PRINT_VAR command, 2 for second etc.>>Case field>---------->Type 1, 2, 3, 4 or 5 here as an ID for the case.>I mean, at the same time maximum five texts can be printed with this method.>If you want to use an ID for another text, first you need to remove the other text with the same ID off the screen.>>Important!>IdParamList numbers - just like the ID numbers of any Parameters command - can have their own ranges for each level.>But, on the other hand, case ID numbers of PARAM_PRINT_VAR are valid for the whole game! Which means that you need to remove these texts just when the FINISH trigger is just being also activated, or else the texts remain on the screen during the loadscreen and even for the next level. >If you want to remove a text which was activated on a previous level, then just activate a PARAM_PRINT_VAR in "remove" mode which has the same parameters as the PARAM_PRINT_VAR that started the text in the previous level.>>PositionX and PositionY fields>------------------------------>The upper left coordinate of the textbox is where the textbox position is defined.>- In PositionX field you can define the "left" part of that "upper left", i.e. the distance (in micro units) between the left edge of the screen and the left edge of the textbox.>- In PositionY field you can define the "up" part of that "upper left", i.e. the distance (in micro units) between the upper edge of the screen and the upper edge of the textbox.>>"Micro units" are used instead of pixels. Why?>Because micro units result for the same for everyone, but pixels result different positions, according to the screen resolution. With bigger coordinates this difference could be really big.>So go into NG Center, and open Get Screen Frames tool on Tools tag. Type numbers or use the mouse to draw a rectangle. You can see the rectangle PositionX and PositionY values in the boxes, in micro units, which you need to type in these script fields.>>If you type a positive number in any of these script fields, then that is a micro unit value.>But if you type a negative number, than that is the ID of a new variable.>See F589 trigger of this plugin for the required ID (clicking on P button next to Timer window).>For example:>As you can see, the ID for Global Integer Nvar38 (GIN38) is 37, so type -37 now if you want the field value to be (in micro units) the value stored as the actual value of GIN38. (So -1 is not IGNORE now, but ID1 GIN2.)>Only global an local new integer variables (GIN and LIN) are useable now!>>Note:>The ID of GIN1 variable is 0. "Minus 0" is naturally not valid, type -90 now. (Because the ID range for the other variables here is between -1 and -89.)>>Size field>---------->Type the value for the required character size:>>1 - little (absolute)>2 - little (relative, related to the actual font size)>3 - normal (the actual font size)>4 - big (relative, related to the actual font size)>>Color field>----------->Choose a classic trng.dll CL_... constant for the character color.>>Text field>---------->Type the ID of an ExtraNG string here, where your custom text is stored.>>Value1, 2, 3 fields>------------------->See F589 trigger of this plugin for the required ID.>For example:>As you can see (clicking on P button next to Timer window), the ID for Global Integer Nvar38 (GIN38) is 37, so type 37 now if you want to print the actual value of GIN38.>Or, SaveGame Memory Zone Field#75 (distance travelled) ID is 165, so type 165 now if you want to print the actual value of that field.>Or, the timer of the item which is the actual subject of Item Memory Zone is stored in Field#13 of the zone, which is ID197, so type 197 now if you want to print the actual timer value.>Etc.>>Type IGNORE (-1) in a field if you don't need that. (For example, if you have only two values to show then you don't need the third field, type IGNORE there.)>>Note:>After all, this is a casual printing trigger, so if you print IGNORE in all these fields, then it will simply print a text - without printing any variables or memory zone fields.>>How it works>------------>For example, you have 5 big medipacks and 12 small medipacks in the inventory, when you print the text on the screen with those amounts:>>You have just 5 big medipacks and 12 small medipacks in the inventory.>>Parameters= PARAM_PRINT_VAR, 1, 3, 100, 90, 3, CL_RED, 14, 149, 148, IGNORE>>So (in Case 3) you have Position 100/90, normal character size (3), red color, having the text in Extra string14. The values must be added in the order as they go into the text: first big medipack amuont (Savegame Field#59 - ID: 149), then small medipack amount (Savegame Field#58 - ID: 148).>The text in that String#14 must look this way:>>You have just %d big medipacks and %d small medipacks in the inventory.>>So where you type %d, there will be placed the required values:>- the first value (ID149) is placed where the first %d is,>- the second value (ID148) is placed where the second %d is.>>Special characters>------------------>%0.3f>Type this instead of %d if the value is floating.>>Note:>The "0.3" refers to the digits after the decimal point. We work with three digits in our floating nvars, that is why we need 0.3.>However, if you are sure that you want to show a number with different digits, then you can choose another number. For example, for the "3.14" value of Pi, only with two digits, you can type %0.2f. With the usual %0.3f, 3.140 will be printed for Pi with 3.14 on the screen.>If you install this plugin when you have another source for floating values as well, for example from another plugin, perhaps with more digits than three, then you can type even bigger numbers than 3. For example, %0.15f is for fifteen digits after the decimal point.>The default value is six, so a simple %f ends up in six digits.>>An example:>>Parameters= PARAM_PRINT_VAR, 2, 1, 40, 190, 1, CL_BLUE, IGNORE, 19, 59, 225, IGNORE>>So you need to type Local Int Nvar15 (ID59) and then Global Float Nvar2 (ID225) in Extra String19, which has this text:>>The values are %d and %0.3f.>>\t>Type this for one tabulation.>>\n>Type this to start a new line.>>\">You need to type this to print a " sign on the screen. A simple " results an error now.>>%%>As you can see, % sign is important for %d or %f. If you really want to print a % sign on the screen, then type %% in the string. For example, if the value is 15, and you want to print 15 % for 15 percents, then type %d %%.>>\\>As you can see above, \ sign also has a special meaning, so type \\ if you really want to see a \ sign on the screen.

PARAM_MENU_TRIGGER: 4 ;Used with Parameters command.>You need this in F593 triggers if you want to activate a trigger in a menu (or in a loadscreen) - which is usually impossible, with other methods, as you definitely know.>>Syntax: Parameters=PARAM_MENU_TRIGGER, IdParamList, Case, TriggerID, TitleMenu, InGameMenu, LoadScreen, Key, Timer, LinkID, Loop>>Note:>"False and true" conditions used in this setup are unnecessary and serious bug sources. I mean, eg. the "inventory is not open and Paused menu is open" condition is useless, because it is clear that the inventory must be closed if Paused menu is open, so a simple "Paused menu is open" condition now must be enough.>>IdParamList field>----------------->This is a progressive number to identify this "Parameters=PARAM_MENU_TRIGGER" command script in trigger window of ngle.>You'll type 1, for your first PARAM_MENU_TRIGGER command, 2 for second etc.>>Case field>---------->Type 1, 2, 3, 4 or 5 here as an ID for the case.>I mean, at the same time maximum five triggers can be controlled in menus/loadscreens, in the same level.>If you want to use an ID (already used) for another trigger, at the same level, then it is possible, but the previous trigger with that ID will not work during menus/loadscreens from now on.>>Don't forget: triggers affect only their own levels, so even if you want the same thing (with the same case ID or not), but in more than one level, then you need an F593 for it in each of those levels.>>TriggerID field>--------------->Type here the ID number of a TriggerGroup Script command. That is the place where you need to store the trigger to be executed in menus/loadscreens.>>If you want to stop controlling a trigger under menus/loadscreens (without adding its case ID to another trigger), then type the ID here with a minus sign, eg. -125 is neededed to be typed to stop controlling TriggerGroup 125 under menus/loadscreens, without adding its case ID to another trigger.>>Important!>You cannot handle trigger pairs together. Eg. if you have an F593 to turn on something and another F593 to turn off the same thing in the menus, then they refer to different TriggerGroups: one TriggerGroup+one F593+one PARAM_MENU_TRIGGER for the "on" trigger, and another TriggerGroup+another F593+another PARAM_MENU_TRIGGER for the "off" trigger.>That is why these also have different case IDs!>>TitleMenu field>--------------->Type a TITLEMENU flag here to define in which title menus you want this feature to work.>Add the flags to each other with a "+" sign, if you want it for more than one title menus.>>Type IGNORE (-1) if you use this feature for else but title menus.>Also type IGNORE (-1) if the number in TriggerID field is negative.>>Add a MENU_NON flag to the TITLEMENU flag(s) if you want to check not that if the menu(s) is/are ON, but OFF.>>Note:>PARAM_MENU_TRIGGERs for title menus naturally go into the Title script section.>>InGameMenu field>---------------->Type an INGAMEMENU flag here to define in which in-game menus you want this feature to work.>Add the flags to each other with a "+" sign, if you want it for more than one in-game menus.>>Type IGNORE (-1) if you use this feature for else but in-game menus.>Also type IGNORE (-1) if the number in TriggerID field is negative.>>Add a MENU_NON flag to the INGAMEMENU flag(s) if you want to check not that if the menu(s) is/are ON, but OFF.>>Keep this thing in your mind if your purpose is turning some drawn thing (text, sprite etc.) on or off in an in-game menu:>If there is something (text, sprite etc.) drawn on the screen BEFORE the required in-game menu (inventory, paused+submenus, save/load menus) is on, then - showing that menu - that drawn thing won't be removed off the screen, if you want it to turn off when that menu is on. I mean, the drawn thing will be only drawn in the background now, looking passive BEHIND the menu screen. So that is what "thing is removed" means now. This thing will be really removed only if you close that menu after that (except if you want to restore it after the menu closes).>A similar thing happens if you don't want to remove the drawn thing - already on the screen - off the screen when you open the menu. I mean, this time the active version of the thing (above the menu screen) and the passive version of the thing (behind the menu screen) will be both seeable, like an object and its shadow. The "shadow" will be removed only if you close the menu after that.>On the other hand, if you both open and close the drawn thing when you inside the menu, there won't be any "shadow" like that, everything will look normal.>>Note:>PARAM_MENU_TRIGGERs for in-game (level) menus naturally go into the required Level script section.>>LoadScreen field>---------------->Type a LOADSCREEN flag here to define in which loadscreen you want this feature to work.>Add the flags to each other with a "+" sign, if you want it for more than one loadscreen types.>>Type IGNORE (-1) if you use this feature for else but loadscreens.>Also type IGNORE (-1) if the number in TriggerID field is negative.>>Add a MENU_NON flag to the LOADSCREEN flag(s) if you want to check not that if the loadscreen(s) is/are ON, but OFF.>>Keep these things in your mind if your purpose is to activate a trigger for a loadscreen:>>a, Loadscreens always belong to the game section wherefrom (not whereto!) the loading procedure will happen. For example, if you starts loading a savegame of Level B, but when you are in Level A, then that loadscreen is of Level A, I mean only Level A triggers will affect it, not Level B triggers. (So the PARAM_MENU_TRIGGER for this trigger goes into Level A script section.)>Or, you want to check the loadscreen that loads the game from the title, to print something if the loadscreen pops up, and then to remove it if the loadscreen ends. The "loadscreen is present" situation should be checked in the title, whereto this loadscreen belong. But, after the loadscreen, that is that level, not the title, so the "loadscreen is not present" situation should be checked in that level.>b, Just think about this situation:>>1. You save the game when Lara is in Position A.>2. Then Lara moves from Position A to an F593 trigger to print a text under a load game loadscreen, activating the trigger.>3. Then you load the savegame to Position A. The text will be printed when the loadscreen pops up.>4. Then the text will be removed when the loadscreen ends, having Lara in Position A. However, you didn't activate a trigger to remove the text, it must be a bug!>5. Then Lara doesn't move from Position A, you load that savegame again. The text won't be printed again, it must be another bug!>>No, none of them is a bug. But you forgot about the logic of the triggers:>I mean, at the first "bug" you load a position (Position A) which was recorded BEFORE activating F593. So in the moment, when the loading procedure ends, the trigger becomes a "never-executed-so-far" trigger, there is no need a reason for the text to remain on the screen.>The second "bug" has the same issue: when you load Position A at the second time, then that happens BEFORE activating F593, so there is no reason for the text to be printed.>>Notes:>- In many situations the thing activated for the loadscreen will be aborted everyway if the loadscreen ends, even if you don't set a trigger to do that. (Which means you didn't "really" abort the procedure, so if the loadscreen pops up the next time, the thing will be activated again.)>- The loadscreen feature perhaps will be buggy if the LoadCamera command at that level refers to a non-existing room.>- Triggers activated by the opening of loadscreens will be probably activated many times about 1-5 tick frames sooner than the opening of the loadscreen. This is naturally hardly noticeable.>- Under some rare circumstances perhaps that happens that the event won't be triggered during a loadscreen.>The reason should be the computer got really slowed down, having far less FPS than 30. I suppose it happens only in older computers.>Anyway, perhaps you should activate only decorative/unimportant things during loadscreens, where it doesn't matter if they won't be activated.>- Technically we could check even "the very first loadscreen", i.e. load.bmp, but the setup would fail, because there is no section in the script to check the load.bmp ("pre-title") phase, with globaltriggers.>That is why load.bmp loadscreen is excluded from F593.>>Key field>--------->This field makes this feature more precise. When the game enters the required menu/loadscreen*, the trigger won't be executed automatically (what it will, anyway, if you type IGNORE here), but only if you also hit the required key in that menu/loadscreen.>>Type the proper scancode ID (see NG Center/Reference/Keyboard Scancodes list) to define the required key.>>Only single keys are accepted now, CTRL+C or anything similar combinations are not!>>Timer field>----------->You can adjust some kind of "menu Organizer" here.>I mean, here you can adjust the timer that happens between this trigger and the next one. (This next event must be defined in LinkID field.)>>The timer must be typed here in tick frames (30 frames = 1 second), the maximum is about 18 minutes.>>The timer will start at the same time when the first event is executed. (I.e. when the menu/loadscreen opens*, or - if some key is added in Key field - when you hit the required key). If the timer requires, the linked second event will be executed.>>Important!>Even if you don't type a TriggerGroup ID in the LinkID field, you can type a timer value here.>In this case the timer will have a different meaning, i.e. the timer will belong to the first event:>When the menu/loadscreen opens*, or (if some key is added in Key field) when you hit the required key, then the first (and only) event won't be executed, but the timer starts. If the timer requires, the event will be executed.>>Naturally the timer will be aborted if the menu/loadscreen closes* before the time expires, the timed event will not happen.>>Type IGNORE (-1) if you don't want to link a next event to the first one, or if you don't want to time the first event.>>Notes:>- Non-loop timers cannot be aborted with keys.>- If a non-loop timer expires, you cannot repeat simply hitting the starting key to restart it (if you have a starting key). First you need to close/re-open* the menu/loadscreen.>See about loop timers below.>- For events that need a "single shot resumed" feature, the timer could be useful. For example, adjust 1 tick frame timer for the first event when that event is a sound flipeffect, for the inventory main menu. It results that the sound won't be started again and again each time after you have opened the inventory, but only at the first tick frame, when opening it.>>LinkID field>------------>Type here the ID number of a TriggerGroup Script command. That is the place where you need to store the trigger to be executed when the timer of the Timer field expires.>>Type IGNORE (-1) if you don't want to link a next event to the first one.>>In a linked case, if you want to keep the first trigger without this linked second one, then another Parameters=PARAM_MENU_TRIGGER command is needed for the first trigger, saying with IGNOREs that there is no timer, there is no second (linked) trigger any more.>>Loop field>---------->Type here the proper value to identify how to control the timer:>>IGNORE (-1): there is no timer or you don't want a loop.>0: the triggers will be repeated in a "neverending" loop: TriggerID - Timer - LinkID - Timer - TriggerID. When the required menu/loadscreen closes*, then only that will abort it.>any positive number: like loop mode 0, but this time you can also abort the loop before the menu/loadscreen closes*, if you hit the keyboard key whose scancode ID is this positive number.>any negative number: like loop mode 0, but this time you can also abort the loop before the menu/loadscreen closes*, if the timer (in tick frames), whose value is this negative number (without the minus sign), just expires. (1 tick frame will be ignored, because -1 is IGNORE.)>>Note:>- A loop sequence aborted by key/timer can be restarted by simply hitting the starting key to restart it (if you have a starting key), you don't need to close/re-open* the menu/loadscreen before that. (Whenever the previous timer was aborted, it starts a brand new timer.)>- A loop feature is a great thing if you want a blinking thing. For example, you print a blinking text, using F591 triggers in a PARAM_MENU_TRIGGER. The first F591 trigger prints the text on the screen, the second F591 removes it. The loop timer between them is the blinking speed.>>*: or the opposite, if the menu/loadscreen condition is not "menu/loadscreen is open" but "menu/loadscreen is closed".>>Example>------->For example, we want to show a diagnostic screen, with an F588 of this plugin.>>One 588 is exported into TriggerGroup#14 now, to print the diagnostic screen.>Another 588 is exported into TriggerGroup#15 now, to remove the diagnostic screen.>>Activate these commands with two F593 triggers:>>Parameters=PARAM_MENU_TRIGGER, 1, 4, 14, IGNORE, INGAMEMENU_PAUSED+INGAMEMENU_STATISTICS+INGAMEMENU_OPTIONS+INGAMEMENU_CONTROL, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE  ;paused full menu is on>Parameters=PARAM_MENU_TRIGGER, 2, 2, 15, IGNORE, INGAMEMENU_PAUSED+INGAMEMENU_STATISTICS+INGAMEMENU_OPTIONS+INGAMEMENU_CONTROL+MENU_NON, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE  ;paused full menu is off>>If you enter the Paused menu after this, any time, then the diagnostic screen will be typed on the screen. The text will remain there while you are in that menu (including its sub-menus: Statistics, Options, Control Configuration).>If you quit the Paused menu after this, then the text will be removed.>If you enter/quit the Paused menu after this, then the printing/removing event will be always repeated.>>You need one more F593 and one more PARAM_MENU_TRIGGER, to also remove the diagnostic screen, if the player hits "Exit to title" in the Paused main menu, so the game starts loading the title:>>Parameters=PARAM_MENU_TRIGGER, 3, 2, 15, IGNORE, IGNORE, LOADSCREEN_EXIT, IGNORE, IGNORE, IGNORE, IGNORE ;"Exit to title" loadscreen is on>>As you can see, using the same TriggerGroup (15 now) at the same time doesn't require another case ID, so we use 2 again.>>Activate this with further 593 triggers if you don't want the diagnostic screen to pop up (and that is why, if you don't want to close it) the next time when you open the Paused menu:>>Parameters=PARAM_MENU_TRIGGER, 4, 4, -14, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE>Parameters=PARAM_MENU_TRIGGER, 5, 2, -15, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE >>Now Case ID 2 and 4 have got free.>>Later you want exactly that diagnostic screen to pop up again when the game enters any load game menu in-game (but not when enters title load game menu), and you want to remove it when the game starts to load them (i.e. if you had selected a savegame, so the menu got closed) - that is why you need two more F593 triggers (not with the original case IDs of the triggers, because they were added to other triggers in the meantime):>>Parameters=PARAM_MENU_TRIGGER, 6, 1, 14, IGNORE, INGAMEMENU_INV_LOAD+INGAMEMENU_F6_LOAD, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE  ;any of the in-game load game menus are on>Parameters=PARAM_MENU_TRIGGER, 7, 5, 15, IGNORE, IGNORE, LOADSCREEN_GLOAD_INV+LOADSCREEN_GLOAD_F6, IGNORE, IGNORE, IGNORE, IGNORE  ;loadscreens from any in-game load menus are on>>Later you don't need this feature any more. In the same moment, you need case ID 1 and 5 for other TriggerGroups, so you "steal" case ID 1 and 5 with other F593 triggers for those other TriggerGroups.>>More later, you want to print that diagnostic screen again, during the Statistic screen, each time when you also hit Key D ("Diagnostic") when the menu is on, but maximum only for 5 seconds.>>What you need now are two more F593 triggers:>>- to print the diagnostic screen when Statistic is on, plus if D is hit, but to remove it if 5 seconds has been expired,>- to remove the diagnostic screen and abort the timer if you hit ESC to close Statistics, going back to Paused main menu. (Timer abortion is automatically made by the code, you don't need to do anything with it.)>>Let's suppose all the case IDs got free in the meantime, so we can freely use eg. 1 and 2 now:>>Parameters=PARAM_MENU_TRIGGER, 8, 1, 14, IGNORE, INGAMEMENU_STATISTICS, IGNORE, 32, 150, 15, IGNORE  ;Statistic screen is on, Key D scancode (32) is hit, 150= 5 seconds (5×30 tick frames) are adjusted>Parameters=PARAM_MENU_TRIGGER, 9, 2, 15, IGNORE, INGAMEMENU_PAUSED, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE  ; paused main menu is on>>Later you keep the case ID 1 and 2 to reform the menu feature of this diagnostic screen for something else.>I mean, what you want is a blinking diagnostic screen, being on and off the screen only for 0.66 seconds (20 frames), in the Examine display, never aborting the loop, while the display is on, that is why you define two other F593 triggers and PARAM_MENU_TRIGGERs with case ID 1 and 2, to also remove PARAM_MENU_TRIGGER#8 and PARAM_MENU_TRIGGER#9:>>Parameters=PARAM_MENU_TRIGGER, 10, 1, 14, IGNORE, INGAMEMENU_EXAMINE, IGNORE, IGNORE, 20, 15, 0  ;Examine is on, 20 tick frames are adjusted>Parameters=PARAM_MENU_TRIGGER, 11, 2, 15, IGNORE, INGAMEMENU_INVENTORY+INGAMEMENU_EXAMINE+INGAMEMENU_INV_LOAD+INGAMEMENU_INV_SAVE+MENU_NON, IGNORE, IGNORE, IGNORE, IGNORE, IGNORE  ;you hit ESC not only to exit Examine display, but also exit the whole inventory>>And one more example:>Timer is a good thing for "single shot resumed" types events, I said above, but it is not always the best way.>I mean, for example you have TriggerGroup#16 to add one medipack to the inventory when you hit M ("Medipack") key (code: 50), being in the inventory:>>Parameters=PARAM_MENU_TRIGGER, 12, 3, 16, IGNORE, INGAMEMENU_INVENTORY, IGNORE, 50. IGNORE, IGNORE, IGNORE>>But it is wrong. I mean, if you push the key more than one tick frame (and it is really hard to push it for only one tick frame), then 1 will be added to the amount at each tick frame. The timer I said above, could help:>>Parameters=PARAM_MENU_TRIGGER, 12, 3, 16, IGNORE, INGAMEMENU_INVENTORY, IGNORE, 50, 1, IGNORE, IGNORE>>The problem is that Timer 1 means "1 tick frame after the inventory opens", so if you want to hit Key M again, to add one more medipack, then you need to close the inventory first and then reopen it.>An imperfect solution:>>Parameters=PARAM_MENU_TRIGGER, 12, 3, 16, IGNORE, INGAMEMENU_INVENTORY, IGNORE, 50, 15, 16, 30>Parameters=PARAM_MENU_TRIGGER, 13, 4, 17, IGNORE, INGAMEMENU_INVENTORY, IGNORE, 32, 15, 17, 30>>PARAM_MENU_TRIGGER#12 says now that after the first moment a new key input for Key M won't be accepted, because a timer starts for 15 tick frames (=half a second). When the timer expires, the second 16 says that another medipack will be added. So this is a loop, one medipack will be added at each half second automatically, so you have time enough to abort it if you find the amount is enough. 30 says Key A ("Abort") will also abort the procedure, without quitting the inventory.>TriggerGroup#17 is removing a medipack. If you find your medipack amount is too big, then you (after aborting increasing, even not quitting the inventory) can decrease it, hitting Key D (Code 32 = "Decrease"). As you can see in 15 and 17, another loop starts now, to remove one medipack at each half tick frame, and it can also be aborted with Key A.>>The setup is imperfect, because:>>- The increasing and decreasing procedures can work even at the same time (if you start decreasing before aborting increasing, or vice verse). This time the medipack counter naturally only is shivering around an amount.>- Reaching 0 medipack when decreasing, the number of 0 won't be printed in the inventory. Plus, though, nothing happens, the decreasing procedure continues, you need to abort it.>>Feel free to try to make the setup perfect.

TITLEMENU_MAIN:$0001; Used with Parameters=PARAM_MENU_TRIGGER command.>For the main title menu. (Excluding Select Level, Load Game an Options title menus.)

TITLEMENU_SELECT:$0002; Used with Parameters=PARAM_MENU_TRIGGER command.>For Select Level submenu in title.

TITLEMENU_LOAD:$0004; Used with Parameters=PARAM_MENU_TRIGGER command.>For Load Game submenu in title.

TITLEMENU_OPTIONS:$0008; Used with Parameters=PARAM_MENU_TRIGGER command.>For main Options submenu in title. (Excluding Control Configuration.)

TITLEMENU_CONTROL:$0010; Used with Parameters=PARAM_MENU_TRIGGER command.>For Control Configuration submenu in title.

INGAMEMENU_PAUSED:$0001; Used with Parameters=PARAM_MENU_TRIGGER command.>For the main paused menu. (Excluding Statistics and Options.)

INGAMEMENU_STATISTICS:$0002; Used with Parameters=PARAM_MENU_TRIGGER command.>For the Statistics menu.>>Note:>It doesn't work if you make the Statistics menu pop up with trng.dll F223.

INGAMEMENU_OPTIONS:$0004; Used with Parameters=PARAM_MENU_TRIGGER command.>For main Options menu. (Excluding Control Configuration.)

INGAMEMENU_CONTROL:$0008; Used with Parameters=PARAM_MENU_TRIGGER command.>For Control Configuration menu.

INGAMEMENU_INVENTORY:$0010; Used with Parameters=PARAM_MENU_TRIGGER command.>For main Inventory menu. (Excluding save/load menus and the Examine display.)>>Note:>There are classic inventory features (like, adding an inventory item etc.) and new inventory features (like, change the audio, or printing a custom text, in the inventory etc.).>If you execute an F593 trigger "to perform a menu trigger for a classic feature when you open the inventory the next time", then the execution will be buggy (missing or inaccurate), if it is the first opening of the inventory at that level.>So you must be sure that you have opened the inventory at least once at that level before, if you execute an F593 for a menu trigger with a classic feature. (There are no similar bugs for new features.)

INGAMEMENU_INV_LOAD:$0020; Used with Parameters=PARAM_MENU_TRIGGER command.>For in-game load game menu, from the inventory.

INGAMEMENU_F6_LOAD:$0040; Used with Parameters=PARAM_MENU_TRIGGER command.>For in-game load game menu, from the single, standalone menu (F6).

INGAMEMENU_INV_SAVE:$0080; Used with Parameters=PARAM_MENU_TRIGGER command.>For in-game save game menu, from the inventory.

INGAMEMENU_F5_SAVE:$0100; Used with Parameters=PARAM_MENU_TRIGGER command.>For in-game save game menu, from the single, standalone menu (F5).

INGAMEMENU_EXAMINE:$0200; Used with Parameters=PARAM_MENU_TRIGGER command.>For Examine display.

LOADSCREEN_NEW_MAIN:$0001; Used with Parameters=PARAM_MENU_TRIGGER command.>For new game loadscreen from title main menu.

LOADSCREEN_NEW_SELECT:$0002; Used with Parameters=PARAM_MENU_TRIGGER command.>For new game loadscreen from title select level menu.

LOADSCREEN_TLOAD:$0004; Used with Parameters=PARAM_MENU_TRIGGER command.>For saved game loadscreen from title.

LOADSCREEN_GLOAD_INV:$0008; Used with Parameters=PARAM_MENU_TRIGGER command.>For saved game loadscreen in-game. (The route from the inventory.)

LOADSCREEN_GLOAD_F6:$0010; Used with Parameters=PARAM_MENU_TRIGGER command.>For saved game loadscreen in-game. (The route from the standalone menu.)

LOADSCREEN_BLOAD:$0020; Used with Parameters=PARAM_MENU_TRIGGER command.>For "backup" saved game loadscreen.>>Important!>F98 to load the "backup" savegame is useless now. Choose instead F594 of this plugin.

LOADSCREEN_EXIT:$0040; Used with Parameters=PARAM_MENU_TRIGGER command.>For "Exit to title" loadscreen.

LOADSCREEN_DEATH:$0080; Used with Parameters=PARAM_MENU_TRIGGER command.>For Lara's death loadscreen to title.

LOADSCREEN_LJUMP:$0100; Used with Parameters=PARAM_MENU_TRIGGER command.>For level jump loadscreen to a level.>>Important!>Always use F592 of this plugin now for a level jump.

LOADSCREEN_TJUMP:$0200; Used with Parameters=PARAM_MENU_TRIGGER command.>For level jump loadscreen to title.>>Important!>Always use F592 of this plugin now for a level jump. You need to choose Level99 now to load back to the title properly.>This setup fails:>- if your level amount is at least 98 (which is technically impossible nowadays),>- using other level ID in F592 to load to title than 99.

MENU_NON:$0400; Used with Parameters=PARAM_MENU_TRIGGER command.>If you want to check if a menu/loadscreen is NOT on.

PARAM_SPRITE_DISPLAY: 5 ;Used with Parameters command.>You need this in F595 triggers, if you want one of them:>>- to show the sprite in a variable-based position, instead of the constant position of trng.dll PARAM_SHOW_SPRITE, or>- to show the sprite with fading-in/out, which is not possible with PARAM_SHOW_SPRITE, or>- to show the sprite under menus or loadscreens. (Because the similar trng.dll trigger can't do that. See F593 for more details.)>>Syntax: Parameters=PARAM_SPRITE_DISPLAY, IdParamList, Case, SpriteSlot, SpriteID, PosX, PosY, Width, Height, Opacity, FadeIn, FadeOut, Timer>>IdParamList field>----------------->This is a progressive number to identify this "Parameters=PARAM_SPRITE_DISPLAY" command script in trigger window of ngle.>You'll type 1, for your first PARAM_SPRITE_DISPLAY command, 2 for second etc.>>Case field>---------->Type 1, 2, 3, 4 or 5 here as an ID for the case.>I mean, at the same time maximum five sprites can be showed with this method, in the same level.>If you want to use an ID (already used) for another trigger, at the same level, then it is possible, but the previous sprite with that ID will be removed off the screen. (Naturally if that previous sprite is removed before "stoling" its case ID, then using this free case ID will not do anything with that previous sprite.)>>SpriteSlot field>---------------->Type here the name of the WAD object where the sprite is stored: CUSTOM_SPRITES, DEFAULT_SPRITES, MISC_SPRITES.>>SpriteID field>-------------->Type here the sprite ID number that the required sprite has in that object.>>PosX, PosY, Width, Height fields>-------------------------------->The upper left coordinate of the sprite is where the sprite position is defined:>- In PosX field you can define the "left" part of that "upper left", i.e. the distance (in micro units) between the left edge of the screen and the left edge of the sprite.>- In PosY field you can define the "up" part of that "upper left", i.e. the distance (in micro units) between the upper edge of the screen and the upper edge of the sprite.>>Width field hosts the horizontal size of the sprite (in micro units).>Height field hosts the vertical size of the sprite (in micro units).>>"Micro units" are used instead of pixels. Why?>Because micro units result for the same for everyone, but pixels result different positions, according to the screen resolution. With bigger coordinates this difference could be really big.>So go into NG Center, and open Get Screen Frames tool on Tools tag. Type numbers or use the mouse to draw a rectangle. You can see the rectangle PosX, PosY, Width and Height values in the boxes, in micro units, which you need to type in these script fields.>>If you type a positive number in any of these script fields, then that is a micro unit value.>But if you type a negative number, than that is the ID of a new variable.>See F589 trigger of this plugin for the required ID (clicking on P button next to Timer window).>For example:>As you can see, the ID for Global Integer Nvar38 (GIN38) is 37, so type -37 now if you want the field value to be (in micro units) the value stored as the actual value of GIN38. (So -1 is not IGNORE now, but ID1 GIN2.)>Only global an local new integer variables (GIN and LIN) are useable now!>>Note:>The ID of GIN1 variable is 0. "Minus 0" is naturally not valid, type -90 now. (Because the ID range for the other variables here is between -1 and -89.)>>Opacity field>------------->Type 1 if the sprite is full opaque.>Type 0 if the sprite is semi-transparent.>>FadeIn field>------------>This field will be checked only if you use an F595 to show the semi-transparent sprite.>>Type a positive number to show the sprite (approximately) in that amount of tick frames, by degrees (i.e. with fading), from nothing to the semi-transparent state. (The maximum is about 14 minutes.)>>In other cases, type IGNORE (-1). (Full opaque sprites will be shown always immediately, but if you type IGNORE for a semi-transparent sprite, that will also be shown immediately.)>>Notes:>- If you experience a little, unwanted blink at the end of the fading-in procedure, then change this timer a bit. For example, if you type 30 tick frames for one second, then modify it to 29 or 31 tick frames.>- Fading-in below 1 second probably will be a bit ugly, because those unwanted blinks can't really be fixed.>>FadeOut field>------------->This field will be checked only if you use an F595 to remove the semi-transparent sprite. (Or if you use timer - see below - to remove the semi-transparent sprite.)>>Type a positive number to hide the sprite (approximately) in that amount of tick frames, by degrees (i.e. with fading), from the semi-transparent state to nothing. (The maximum is about 14 minutes.)>>In other cases, type IGNORE (-1). (Full opaque sprites will be hidden always immediately, but if you type IGNORE for a semi-transparent sprite, that will also be hidden immediately.)>>Timer field>----------->This field will be checked only if you use an F595 to show the full opaque/semi-transparent sprite.>>Type a positive number here, which means tick frames. (Maximum about for 18 minutes.)>The sprite, just placed on the screen, will be removed in that time, automatically.>>If FadeIn field is used to fade in, then the timer starts in the moment when the sprite has been totally faded in.>If FadeOut field is used to fade out, then the fading-out starts in the moment when the timer expires.>>Type IGNORE (-1) if you don't want to time the sprite. (Or if it is an F595 to hide the sprite.)>>Note:>Typing 0 here, and also using FadeIn and FadeOut naturally results the sprite starts fading out in the moment when it has been totally faded in. So it is a pulsing sprite, for one pulse.>If you want a longer, "neverending" loop pulsing for that case, then type -2 here, instead of 0. Then later you need another F595 to hide the sprite, that will abort the pulsing.>(If you want not a pulsing but a blinking sprite, turning it on/off rhytmically, then see PARAM_MENU_TRIGGER: you don't need a timer or fading features in PARAM_SPRITE_DISPLAY, all you need is an F595 to show the sprite, and another one to hide it, in PARAM_MENU_TRIGGER.)

PARAM_RAINDROP: 6 ;Used with Parameters command.>You need this in F596 triggers, to show "raindrop marks on the camera lens".>>Syntax: Parameters=PARAM_RAINDROP, IdParamList, Flags (FRDROP_...), WFallObject, WFallDistance1, WFallDistance2, SpriteSlot, SpriteID, SpriteWidth, SpriteHeight, Opacity, ScreenX, ScreenY, ScreenWidth, ScreenHeight, ChanceOn, ChanceOff, OffTime1, OffTime2, MaxAmount, DisableMode, Extra1, Extra2>>Important!>- You can have maximum one valid raindrop mark setup (=one valid PARAM_RAINDROP) at the same time, in the same level!>If you enable a new setup before disabling the old one, then the old one will be automatically disabled immediately.>- Each "enabling" trigger starts with wiping the actual marks off the screen. (But, on the other hand, the drips of the wet Lara will never be removed by that. If you want that, then you should also try to activate an F597 at the same time, to stop dripping.)>>IdParamList field>----------------->This is a progressive number to identify this "Parameters=PARAM_RAINDROP" command script in trigger window of ngle.>You'll type 1, for your first PARAM_RAINDROP command, 2 for second etc.>>Note:>Actually, it doesn't matter which PARAM_RAINDROP ID you choose in the trigger if you disable this feature, because there can be maximum one PARAM_RAINDROP setup at the same time, and that will be disabled now everyway.>But always the DisableMode value (see below) of the chosen ID will be executed!>>Flags (FRDROP_...) field>------------------------>Type at least two FRDROP flags here (adding them to each other with Sign +), to adjust how to use this feature. (At least one flag for the feature scene [rain/snow, waterfall, trigger], and at least one for the feature type [sprite, drip].)>>Note:>Drip feature is the dripping Lara feature, used together with the raindrop sprites on the screen. (This time naturally not the position of Lara's camera but Lara's position controls the effect.) This is the same dripping effect that F597 of this plugin produces. So, if you want, avoid the dripping Lara now, and control it directly with an F597.>Or, on the other hand. you can avoid raindrop sprites now, and use PARAM_RAINDROP only to control the dripping Lara.>>WFallObject field>----------------->When we say "waterfalls" in PARAM_RAINDROP, then they should be the places where you can see the animated texture of falling water on traversable room walls or traversable objects.>>For the raindrop sprites and/or for the dripping effect, PARAM_RAINDROP will not detect those traversable waterfalls by itself.>Do you remember the doorposts of TR4? They were traversable, so you need to place dummy, invisible, thin blocks where the posts were.>The waterfall dummy object is something similar: place a dummy, invisible, traversable, paper-thin panels where the waterfall is. PARAM_RAINDROP will detect that dummy object, executing the wanted effect (sprites and/or drips). (Naturally you need another PARAM_RAINDROP, if you want another dummy object - for example, instead of a flat panel of usual waterfalls, you need an object, which fits better with the peculiar shape of a fountain.) - Naturally you don't need the dummy object to cover exactly the place where the waterfall is. All you need is to place the dummy object in the proper position where it can signal to PARAM_RAINDROP that there is a waterfall there.>>You need to type the slot ID of the dummy Static (!) object in this field. (See Static slot ID list in NG Center/Reference.)>Type IGNORE (-1) if this PARAM_RAINDROP is not used for waterfalls.>>Notes:>>- The dummy object naturally always gives only one point to check Lara's distance to the waterfall (probably the center, the pivot of the object). If the waterfall is big, so the dummy object is also big, then you will probably clearly experience that the distance will be checked well only if Lara is close to that point. That is why I suggest if the waterfall is big then create a smaller dummy object, covering the waterfall with several smaller objects like that.>On the other hand:>A big waterfall covered by several tiny panels will not look good always. I mean, for example, when one of the panels says Lara's distance is proper to show the water drops, then perhaps the adjacent panel next to that says Lara's distance is NOT proper to show the water drops. - Which naturally makes the drops show up NOT exactly in the way what you want.>That is why I suggest trying to make your setup for big waterfalls with:>a, toying with panel positons, sizes, shapes, amounts etc. and PARAM_RAINDROP scripted parameters till it seems good, using several panels for one waterfall area, or>b, use only one panel for the whole waterfall area with a distance adjusted which distance won't look really well from all the sides of the waterfall, only from some sides. I mean, placing/removing drops on the screen even too far from/close to the waterfall.>>- If the dummy object is a rectangle, flat panel, then it is really easy to create it with WADMerger:>1. First, create a tiny invisible (magenta) tile.>2. Open the WAD in WADMerger.>3. Click on "Make shatter" button.>4. Load the magenta tile.>5. Choose the required clicks for the height.>6. Click on "Build" button to create a flat Shatter object in the WAD.>7. Turn the Shatter into any non-Shatter Static slot (with "Rename" button).>8. Save the WAD.>9. Load the WAD to the level.>10. Place the Static anywhere in the level.>11. Try the Static in the game. Maybe it doesn't look invisible everywhere, having magenta spots on it.>12. Load the Static into StrPix.>13. Fix the magenta parts. (Perhaps you cannot see the issues now where you could see them in the game, so you should keep in mind where those spots are. Just place the magenta tile there - though, you can see that is still magenta, even without doing that.)>14. Turn all the collision box values to 0, to make the Static traversable.>15. Save the WAD.>16. Load the WAD to the level.>>WFallDistance1 field>-------------------->Type a value here. It is the number of units. (1024 units = 1 sector = 4 clicks.)>If Lara is (approximately) closer to the Static waterfall object (see above) than that (from any direction), then that will be considered as "she is close to the waterfall, marks should be drawn on the camera screen".>>Type IGNORE (-1) if this PARAM_RAINDROP is not used for waterfalls.>>Note:>Things like "Lara turns her back to the waterfall" are not observed now. I mean, water drips can be splashed on the camera even if she is in a position like that, saying eg. that the intensity of the falling water makes the drips fly over the camera, which land on the lens.>>WFallDistance2 field>-------------------->Type a value here. It is the number of units. (1024 units = 1 sector = 4 clicks.)>If Lara is (approximately) closer to the Static waterfall object (see above) than that (from any direction), then that will be considered as "she is close to the waterfall, the dripping Lara effect should be started".>>Type IGNORE (-1) if this PARAM_RAINDROP is not used for the dripping effect.>>SpriteSlot field>---------------->Type here the name of the WAD object where the "raindrop" sprite is stored: CUSTOM_SPRITES, DEFAULT_SPRITES, MISC_SPRITES.>>Type IGNORE (-1) if this PARAM_RAINDROP is not used for raindrop sprites. (But only for "Lara is wet" dripping effect.)>>SpriteID field>-------------->Type here the sprite ID number that the required "raindrop" sprite has in that object.>>Type IGNORE (-1) if this PARAM_RAINDROP is not used for raindrop sprites.>>SpriteWidth, SpriteHeight fields>-------------------------------->SpriteWidth field hosts the horizontal size of one sprite (in micro units).>SpriteHeight field hosts the vertical size of one sprite (in micro units).>>"Micro units" are used instead of pixels. Why?>Because micro units result for the same for everyone, but pixels result different positions, according to the screen resolution. With bigger coordinates this difference could be really big.>So go into NG Center, and open Get Screen Frames tool on Tools tag. Type numbers or use the mouse to draw a rectangle, to simulate the size of one raindrop sprite - the position doesn't matter now, it could be anywhere. You can see the required third and fourth numbers in the brackets, in micro units.>>The third value needs to be typed in the SpriteWidth field.>The fourth value needs to be typed in the SpriteHeight field.>>Type IGNORE (-1) in both fields if this PARAM_RAINDROP is not used for raindrop sprites.>>Opacity field>------------->Type 1 if the sprite is full opaque.>Type 0 if the sprite is semi-transparent.>>Type IGNORE (-1) if this PARAM_RAINDROP is not used for raindrop sprites.>>ScreenX, ScreenY, ScreenWidth, ScreenHeight fields>-------------------------------------------------->This is where you can define the sector of the screen (in micro units) where the raindrops will show up. (I.e. in this area will be placed the upper left corners of all the sprites.)>>ScreenX: the distance between the left edge of the screen and the left edge of the sector.>ScreenY: the distance between the upper edge of the screen and the upper edge of the sector.>ScreenWidth: the horizontal size of the sector.>ScreenHeight: the vertical size of the sector.>>Go into NG Center, and open Get Screen Frames tool on Tools tag. Type numbers or use the mouse to draw a rectangle - which demonstrates the sector. You can see the rectangle ScreenX, ScreenY, ScreenWidth and ScreenHeight values in the boxes, in micro units, which you need to type in these fields.>>In the case of fullscreen:>>ScreenX: 0>ScreenY: 0>ScreenWidth: 1000>ScreenHeight: 1000>>Type IGNORE (-1) in all the fields if this PARAM_RAINDROP is not used for raindrop sprites.>>Note:>If you experience that a static camera view crashes when using the raindrop setup in NOT the fullscreen (0/0/1000/1000), then:>- use fullscreen everyway for that setup, or>- when Lara is not "under raindrop circumstances", then disable/enable the setup. It is enough even for one moment of disablement now.>>ChanceOn field>-------------->Type a number here to define the chance to print the next raindrop on the screen at the next tick frame. (See more info below, at OffTime1 field!)>The number you can type is between 1 and 100.>>If the value is 1 then the chance is 1 % that a mark will be printed on the screen at the next tick frame.>If the value is 2 then the chance is 2 % that a mark will be printed on the screen at the next tick frame.>...>If the value is 99 then the chance is 99 % that a mark will be printed on the screen at the next tick frame.>If the value is 100 then the chance is 100 % that a mark will be printed on the screen at the next tick frame.>>Type 0 if you want a random chance between 1 and 100 %, changing it at each tick frame.>>Notes:>- Naturally for example you need to choose a bigger percent if it is a heavy rain.>- The very first mark of the "actual rainy area" shows up immediately everyway.>>Type IGNORE (-1) if this PARAM_RAINDROP is not used for raindrop sprites.>>ChanceOff field>--------------->ChanceOff is the chance to wipe a mark off the screen, "drying it off". (See more info below, at OffTime2 field!)>>The number you can type is between 1 and 100.>>If the value is 1 then the chance is 1 % that the oldest mark will be removed off the screen at the next tick frame.>If the value is 2 then the chance is 2 % that the oldest mark will be removed off the screen at the next tick frame.>...>If the value is 99 then the chance is 99 % that the oldest mark will be removed off the screen at the next tick frame.>If the value is 100 then the chance is 100 % that the oldest mark will be removed off the screen at the next tick frame.>>Type 0 if you want a random chance between 1 and 100 %, changing it at each tick frame.>>Type IGNORE (-1):>>- if you never have a part in the level where new raindrops will not be placed on the screen (so eg. if the whole level is rainy, all the rooms),>- if this PARAM_RAINDROP is not used for raindrop sprites.>>Note:>For example, if there is a wind to make the lens dry in a faster way, then you should choose a bigger chance now.>>OffTime1 field>-------------->Here you can define how fast an old mark should be "dried off" the screen, under rainy (snowy etc.) circumstances.>>It means that OffTime1 works together with ChanceOn if the old marks are being removed while new marks also can be placed on the screen: in snowy/rainy rooms or close to waterfalls.>ChanceOn works without OffTime1, while the maximum amount of raindrops on the screen (see MaxAmount field below) is not reached. But if the maximum amount is reached, then ChanceOn will place a new mark on the screen only if OffTime1 removes another (the oldest) one off the screen, so the maximum amount will not be exceeded.>So, after the maximum amount is reached, and ChanceOn wants to place the next mark, then, in that moment, OffTime1 starts working to remove the oldest mark, immediately or fading it out. In the moment when the oldest mark is gone totally, the new mark will be placed. The calculation to place the next mark with ChanceOn starts only now.>(As you can see, ChanceOff has no effect now to remove a mark.)>>Type a number here between 0 and 32767.>If it is 0, the mark will be removed immediately.>If it is more than 0, the mark will be removed in those tick frames (approximately more or less), fading out by degrees. (For example, 90 means 90 tick frames, i.e. 3 seconds.) (The maximum 32767 value is about 18 minutes.)>>Type IGNORE (-1) if this PARAM_RAINDROP is not used for raindrop sprites.>(Using FRDROP_MAX_STOP, IGNORE should be accepted here, but that is not! Please, type any other number in that case, between 0 and 32767, without their usual effect.)>>Notes:>- Opaque marks can be removed only immediately.>Only in the case of semi-transparent marks you can choose the immediate or the fading version.>- ChanceOn has a "double effect" with OffTime1. So ChanceOn has its own effect as described above, plus another one what it will force on OffTime1.>I mean, eg. if you have 25 % for ChanceOn, then the chance is only 25% that the just running OffTime1 timer goes on at the next tick frame, while the mark in the rainy room is just being faded out.>So the time for fading out a mark probably bigger for a mark, and smaller for another one, using the same OffTime1 adjustment. >Plus, all of that naturally makes the fading effect "not drying off with a smooth rhytm", intentionally. (Which doesn't mean that the smaller the percents seem laggy.)>It makes the random effects more random, more enjoyable.>So only if ChanceOn is 100 %, the marks will be removed during the same time.>- If the OffTime1 timer is just working with ChanceOn to fade out a mark and you go out of the rainy/snowy room/waterfall area, then the timer for that mark will be aborted. The mark, if it is already partially faded out, will be totally restored. - I know, it is not really logical, however, when there are many tiny marks on the screen, you don't even notice that, mostly if the timer is short.>- "Snowy" in the meaning by this setup is not "snow texture is seeable" now, but only "it is snowing there".>>OffTime2 field>-------------->Here you can define how fast an old mark should be "dried off" the screen, out of rainy (snowy etc.) circumstances.>>It means OffTime2 works together with ChanceOff if the old marks are being removed while new marks cannot be placed on the screen: out of snowy/rainy rooms or far from waterfalls.>In the moment when ChanceOff wants to remove the oldest mark, OffTime2 removes it immediately, or starts removing it with fading it out. In the moment when the oldest mark is gone totally, the calculation to remove the next mark with ChanceOff starts.>(As you can see, ChanceOn has no effect now.)>>If Lara is anywhere (either rainy/snowy rooms or not, either close to waterfalls or not), but you disable the feature with another F596, choosing some "remove-by-degrees" (see DisableMode field below), then also the OffTime2+ChanceOff method will remove the marks.>>Type a number here between 0 and 32767.>If it is 0, the mark will be removed immediately.>If it is more than 0, the mark will be removed in those tick frames (approximately more or less), fading out by degrees. (For example, 90 means 90 tick frames, i.e. 3 seconds.) (The maximum 32767 value is about 18 minutes.)>>Type IGNORE (-1) if this PARAM_RAINDROP is not used for raindrop sprites.>>Notes:>- Opaque marks can be removed only immediately.>Only in the case of semi-transparent marks you can choose the immediate or the fading version.>- ChanceOff has a "double effect" with OffTime2. So ChanceOff has its own effect as described above, plus another one what it will force on OffTime2.>I mean, eg. if you have 57 % for ChanceOff, then the chance is only 57% that the just running OffTime2 timer goes on at the next tick frame, while the mark out of the rainy room is just being faded out.>So the time for fading out a mark probably bigger for a mark, and smaller for another one, using the same OffTime2 adjustment. >Plus, all of that naturally makes the fading effect "not drying off with a smooth rhytm", intentionally. (Which doesn't mean that the smaller the percents seem laggy.)>It makes the random effects more random, more enjoyable.>So only if ChanceOff is 100 %, the marks will be removed during the same time.>- If the OffTime2 timer is just working with ChanceOff to fade out a mark and you go back to the rainy/snowy room/waterfall, then the timer for that mark will be aborted. The mark, if it is already partially faded out, will be totally restored. - I know, it is not really logical, however, when there are many tiny marks on the screen, you don't even notice that, mostly if the timer is short.>>MaxAmount field>--------------->Type a number between 1 and 100. This is the maximum number of the raindrop marks on the screen at the same time.>>Type IGNORE (-1) if this PARAM_RAINDROP is not used for raindrop sprites.>>DisableMode field>----------------->This field will be checked only if you use an F596 to disable the effect.>You can choose these values here:>>-1 (IGNORE):>>- if it never stops raining, in any room of your level, or>- if it is enough for you "if Lara leaves the rainy rooms then marks will be removed, till she comes back", but you never want to disable the feature, or>- all the marks will be wiped off/all the drips will be removed immediately (even if it is still raining/snowing around Lara or there is a close waterfall), when disabled.>>1: after the disablement, all the marks will be wiped off/all the drips will be removed in the moment if Lara leaves the rainy/snowy rooms and/or if she gets farther from the waterfalls. Till that moment, this raindrop feature won't stop working.>2: the marks will be wiped off (see ChanceOff field above for the degrees)/the drips will be removed  by degrees, which starts immediately (even if it is still raining/snowing around Lara or there is a close waterfall), when disabled.>3: after the disablement, the marks will be wiped off (see ChanceOff field above for the degrees)/the drips will be removed  by degrees, which starts in the moment if Lara leaves the rainy/snowy rooms and/or if she gets farther from the waterfalls. Till that moment, this raindrop feature won't stop working.>>Notes:>- The "by degrees" procedure to disable naturally will be aborted and the marks will be wiped off "forever", if the water of a pool wipes them off.>- Outside+rain rooms has wind and rain. Outside rooms (without rain) has only wind.>So when I said above that the wind will make the lens dry, then that could work eg. with this setup: Lara is in an outside room, it is raining, there are raindrop marks on the screen. Having a high ChanceOff percent (if you sure that Lara won't go into a non-outside room now, where there is no wind), you disable the raindrop mark feature, having DisableMode=2 value, which all say "Lara is still in the windy rooms, so the lens will be dry and clean very soon".>- Be careful where and how you disable the feature! I mean, for example, don't forget: the marks are based on Lara's camera, the drips are based on Lara itself. So, for example, if Lara leaves the rainy room after the disablement, with DisableMode 3 value, only a bit, so the camera behind her remains in the rainy room, then the drips will be removed, but the marks will not, so if she goes back to the rainy room now, then you won't already see the drips but you will still see the marks.>>Extra1, Extra2 fields>--------------------->In a latter update of this plugin I would like to enhance this feature.>For example, a nice animation of sprites, demonstrating "water stripes are flowing down the camera lens", if Lara goes over the water surface, coming from under water.>Those features will be hosted in Extra1 and Extra2 fields, but, for the time being, type always IGNORE (-1) in both fields.

FRDROP_RAIN:$0001; Used with Parameters=PARAM_RAINDROP command.>The feature will be used in rainy (or snowy) rooms.

FRDROP_WFALL:$0002; Used with Parameters=PARAM_RAINDROP command.>The feature will be used close to waterfalls.>>Note:>If you use FRDROP_RAIN for rainy/snowy rooms when you also use FRDROP_WFALL, then FRDROP_WFALL will not perform any plus effect for waterfalls in those rainy/snowy rooms.

FRDROP_TRIGGER:$0004; Used with Parameters=PARAM_RAINDROP command.>If you use FRDROP_RAIN or FRDROP_WFALL, several circumstances are important. For example, in the case of FRDROP_RAIN:>- Enabling the effect, the marks will start showing up if the camera is in a rainy room now or after that.>- If Lara leaves the rainy room, the marks starts drying off.>- Disabling the effect, according to what you chose in DisableMode field, the marks will be removed immediately/by degrees and now/later.>>But, if you choose FRDROP_TRIGGER, then only the moment of enabling/disabling trigger itself what matters, other circumstances have no effect:>- Enabling the effect, the marks will start showing up immediately.>- Whatever Lara does after that, that won't affect the effect.>- Disabling the effect, according to what you chose in DisableMode field, the marks will be removed immediately/by degrees, but always now, not later. (Which means choosing 1 or 3 in DisableMode field for "later" are useless now, choose only -1 or 2 for "now". If you choose -1 for "immediately", then you don't need ChanceOff and OffTime2 fields, type IGNORE there.)>>FRDROP_TRIGGER is useful if you want to see the marks not controlled by rain/snow/waterfall, but by your custom setup. - For example:>- You want to execute an F596 in the bottom of a very shallow pool. There is a Heavy trigger here to activate F596 (to enable). An Animating jeep drives over the Heavy fast, activating it. The fast speed makes "mud drips splash on the camera lens".>So you need a Heavy F596, and an Animating which is moving, crossing that Heavy. You need a good positioning for Lara, which means the Animating will cross it when Lara is next to the puddle, looking at that direction.>Activate another F596 (to disable) later, when you want to remove the mud drips.>- You want to execute an F596 (to enable) when Lara hurts an enemy close to her. (So probably a TestPosition is needed to detect the presence and the position of the enemy.) It makes "blood drips splash on the camera lens".>Activate another F596 (to disable) later, when you want to remove the blood drips.>>Notes for the cases like those two examples:>- With "splashes" like that, the setup should be something like this: "place the marks fast on the screen one after the other, to reach the maximum amount very soon".>- After "splashes" like that, perhaps there should not be further marks placed on the screen, just after all the blood/mud drips are splashed, so you should stop placing further drips, after reaching the maximum amount. (I mean, as a I said in PARAM_RAINDROP, in the usual case with raindrops older drips are always swapped for newer drips, this is what you can rule out now.) See FRDROP_MAX_STOP for more info.>>General notes:>- You shouldn't use FRDROP_RAIN or FRDROP_WFALL at the same time when you also use FRDROP_TRIGGER.>- Another possible trigger-controlled setup for drips is using F597.>- If Lara's camera will be swapped for a static/flyby camera or a binoculars/lasersight display (or vice verse), then nothing will happen. (As opposed to FRDROP_RAIN/FRDROP_WFALL, when it will.)>If you don't like it then you need to solve it manually. For example, if the marks are on the screen when you extract binoculars/lasersight:>a, With GT_USING_BINOCULAR trng.dll constant you can have a GlobalTrigger to remove the marks if Lara is looking throgh binoculars.>Another GlobalTrigger, "when Lara is NOT looking through", will re-trigger F596 to re-enable the marks.>b, With GT_CONDITION_GROUP trng.dll constant, plus, with C163 trigger of my first (Plugin_AkyVMix01) plugin, you can have a GlobalTrigger to remove the marks if Lara is looking throgh the lasersight.>Etc.

FRDROP_SPRITE:$0008; Used with Parameters=PARAM_RAINDROP command.>The feature is about placing raindrop sprites on the camera lens.

FRDROP_DRIP_IN:$0010; Used with Parameters=PARAM_RAINDROP command.>The feature is about making water drips dripping from Lara (with constant, maximal intensity) even if when she is in that "watery" feature (rain, snow, waterfall). Leaving that area, the dripping starts stopping, by degrees, as usual, but not immediately - so you don't need for FRDROP_DRIP_OUT now.

FRDROP_DRIP_OUT:$0020; Used with Parameters=PARAM_RAINDROP command.>The feature is about making water drips dripping from Lara for a while, only when she has just left that "watery" feature (rain, snow, waterfall).>>Notes:>- If you use FRDROP_DRIP_OUT for when Lara leaving the rainy rooms, then please don't use FR_ADD_DRIPS_TO_LARA with CUST_RAIN now collaterally, for the same reason.>- In the case of FRDROP_DRIP_OUT the sudden disablement (DisableMode field value -1 or 1) is meaningless. Choose only disablement by degrees now (DisableMode field value 2 or 3).>- I don't recommend FRDROP_DRIP_OUT with FRDROP_TRIGGER.

FRDROP_MAX_STOP:$0040; Used with Parameters=PARAM_RAINDROP command.>The older drips won't be removed if you reach the maximum amount, so newer drips will not be placed. So, all the marks, after reaching the maximum, will be kept on the screen, till they are removed (eg. with disablement or leaving the rainy area).>>See an example for this in FRDROP_TRIGGER.

PARAM_ACTUAL_CAM: 7 ;Used with Parameters command.>You need this in C112 triggers, to check some parameters of the actual (chase, look, combat, static, flyby) camera.>>Syntax: Parameters=PARAM_ACTUAL_CAM, IdParamList, Flags (FACTCAM_...), Flags (RTYPE2_...), MainParameter, Additional>>IdParamList field>----------------->This is a progressive number to identify this "Parameters=PARAM_ACTUAL_CAM" command script in trigger window of ngle.>You'll type 1, for your first PARAM_ACTUAL_CAM command, 2 for second etc.>>Flags (FACTCAM_...) field>------------------------->This is where you define what you want to observe about the camera.>Choose only one flag! (If you want to check more than one parameter at the same time, then you need more than one PARAM_ACTUAL_CAM at the same time, in different C112 triggers.)>>Flags (RTYPE2_...) field>------------------------>If you chose FACTCAM_CAM_ROOM or FACTCAM_TARG_ROOM as a FACTCAM flag, then you also need one or more RTYPE2 flags here to define the room type, like "water", "horizon" etc.>Type IGNORE (-1):>- if what you observe is not the type of the room, but the room index/flipmap info, or>- if you didn't choose FACTCAM_CAM_ROOM or FACTCAM_TARG_ROOM.>>Add the constants to each other, if you want to check more than one types.>Eg. RTYPE2_COLD+RTYPE2_REFLEX means it is a cold+reflection room.>Or RTYPE2_NON+RTYPE2_DAMAGE+RTYPE2_OUTSIDE means it is not a damage room and not an outside room.>>Notes:>>- The flag is what matters now, not the property. I mean, for example, a room with Rain flag has no rain if it is not an outside room.>- The flags can always be checked for the actual room: for the original room, if it is just original, and for the fliproom if it is just the fliproom.>- Don't misunderstand: you don't need to check all the actual types. So, for example, if the room is an outside+non-lens flare room, and you want to check only if outside is true, then you don't need to check non-lens flare, if you don't want to.>- That number of 2 is typed there for a good reason. I mean, for the same purpose, my first (Plugin_AkyVMix01) plugin have RTYPE flags. To distinguish them from this feature, now I used RTYPE2 flags.>- You can't use ROOM constants now (that you use in MultEnvCondition Script commands for ENV_ROOM_IS)!>>MainParameter field>------------------->Type here one of these values:>- In the case of FACTCAM_CAM_ROOM or FACTCAM_TARG_ROOM, if they are for room ID: the required room ID.>- In the case of FACTCAM_CAM_ROOM or FACTCAM_TARG_ROOM, if they are for flipmap info:>>Type -1111 if you want a true condition only if the room (not a fliproom) has no fliproom.>Type -2222 if you want a true condition only if the room (not a fliproom) has a fliproom in any flipmap.>Type -3333 if the room is a fliproom, in any flipmap.>Type a flipmap ID+4000, with a negative sign, if you want a true condition only if the room (not a fliproom) has a fliproom in that flipmap. (Eg. -4002 = Flipmap 2.)>Type a flipmap ID+5000, with a negative sign, if you want a true condition only if the room is a fliproom in that flipmap. (Eg. -5003 = Flipmap 3.)>>- In the case of FACTCAM_DIST_..., FACTCAM_VERT_...: the required distance, in units. (1024 units = 1 sector.)>- In the case of FACTCAM_ANGLE_...: the required angle, in degrees, from 0 to 359.>- In the case of FACTCAM_CAM_ROOM or FACTCAM_TARG_ROOM, if they are for room types: IGNORE (-1).>>Note:>Never check the ID of a fliproom. Eg. if you want to check if it is a fliproom with ID X, then you can use two different PARAM_ACTUAL_CAMs at the same time: one for the original room ID, and one for if it is a fliproom.>>Additional field>---------------->The values are:>- In the case of FACTCAM_CAM_ROOM or FACTCAM_TARG_ROOM: IGNORE (-1).>- In the case of FACTCAM_DIST_..., FACTCAM_VERT_...:>>a, MainParameter field value repeated: if the distance is equal with the value in MainParameter field.>b, MainParameter field value, minus 1: if the distance is less (or equal) than the value in MainParameter field.>c, MainParameter field value, plus 1: if the distance is more (or equal) than the value in MainParameter field.>d, Any other value: if the distance is between MainParameter field and Additional field. Border values are included. (For example, MainParameter=1024, Additional=900, then we check the interval between 900 and 1024. 900 and 1024 are also true.) Additional field value could be even bigger/smaller than MainParameter field value. (As you probably see, this time it doesn't matter that you write which number in which field. Both 900 and 1024 can be either in MainParameter field or in Additional field.)>>- In the case of FACTCAM_ANGLE_..., you always need to observe an interval:>>a, If the Additional field value is more than MainParameter field value, then you will go from a smaller value to a bigger value. Border values are included. (For example MainParameter=5, Additional=355, so the interval checked is 5, 6, 7... 353, 354, 355 degrees.)>a, If the Additional field value is less than MainParameter field value, then you will go from a bigger value to a smaller value. Border values are included. (For example MainParameter=355, Additional=5, so the interval checked is 355, 356, 357, 358, 359, 0=360, 1, 2, 3, 4, 5 degrees.)>>Notes:>- Perhaps the direction also matters with the distance. For example, we can check if the camera is vertically closer to or farther from the target object, but that doesn't tell that the object is below or above the camera. Another condition with this FACTCAM_DIST_Y together will help you to solve that: a FACTCAM_ANGLE_HOR1 or _HOR2 to check if the camera looks at the floor (so if the target is below it) or looks at the ceiling (so if the target is above it).>- An "equal" orientation condition is "too exact", perhaps it will never be true. If you'd like to check eg. exactly 17 degrees, then perhaps you should check "between 15 and 19" instead, NOT typing 17 in MainParameter field and 17 in Additional field. - Anyway, the same values in MainParameter field and in Additional field are not acceptable now!

FACTCAM_CAM_ROOM:1; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to know something about the room of the actual camera.

FACTCAM_TARG_ROOM:2; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to know something about the room of the target of the actual camera.>>The target of chase, look or combat cameras is always Lara herself.>The target of static cameras is mostly Lara, except if you have a Target trigger to define another target object.>The flag is useless if the actual camera is a flyby camera.

FACTCAM_DIST_3D:3; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to check the 3D distance between the camera and its target.

FACTCAM_DIST_X:4; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to check the X (north-south horizontal, according to Room Editor facing) distance between the camera and its target.

FACTCAM_DIST_Y:5; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to check the Y (vertical) distance between the camera and its target.

FACTCAM_DIST_Z:6; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to check the Z (east-west horizontal, according to Room Editor facing) distance between the camera and its target.

FACTCAM_VERT_FLOOR:7; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to check the vertical distance between the camera and the nearest solid floor below that.

FACTCAM_VERT_CEILING:8; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to check the vertical distance between the camera and the nearest solid ceiling above that.

FACTCAM_VERT_WATER_BELOW:9; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to check the vertical distance between the camera and the water surface below that. (The result will be naturally always false if there is a solid floor between the camera and the water surface.)>>Note:>You can also check "exactly the water surface" (distance = 0) here.

FACTCAM_VERT_WATER_ABOVE:10; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to check the vertical distance between the camera and the water surface above that. (The result will be naturally always false if there is a solid ceiling between the camera and the water surface.)>>Note:>You can also check "exactly the water surface" (distance = 0) here.

FACTCAM_ANGLE_HOR1:11; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to check the rotation of the camera, around the north-south horizontal axis of the camera. (Room Editor facing, not game facing! I mean the editor "north" and the game "north" are not the same.)>>0 degrees means the camera is looking at exactly the ceiling (seeing it from the back of the camera), then you can count the further values always in the same rotation. So 90 degrees means the camera is turned exactly eastwards, 180 degrees means the camera is looking at exactly the floor, 270 means the camera is turned exactly westwards.>>Note:>The camera angle is based on the angle between the camera and the target. But if the target is exactly on the north-south axis on the camera (but anywhere on that axis), then this angle is indeterminable. Type 1000 both in MainParameter and Additional fields if you want to check if this situation is just true.

FACTCAM_ANGLE_HOR2:12; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to check the rotation of the camera, around the east-west horizontal axis of the camera. (Room Editor facing, not game facing! I mean the editor "east" and the game "east" are not the same.)>>0 degrees means the camera is looking at exactly the ceiling (seeing it from the back of the camera), then you can count the further values always in the same rotation. So 90 degrees means the camera is turned exactly southwards, 180 degrees means the camera is looking at exactly the floor, 270 means the camera is turned exactly northwards.>>Note:>The camera angle is based on the angle between the camera and the target. But if the target is exactly on the east-west axis on the camera (but anywhere on that axis), then this angle is indeterminable. Type 1000 both in MainParameter and Additional fields if you want to check if this situation is just true.

FACTCAM_ANGLE_VERT:13; Used with Parameters=PARAM_ACTUAL_CAM command.>Use this if you want to check the rotation of the camera, around the vertical axis of the camera.>>0 degrees is exactly north (seeing it from the back of the camera), then you can count the further values always in the same rotation. So 90 degrees is exactly east, 180 degrees is exactly south, 270 degrees is exactly west. (Room Editor facing, not game facing! I mean the editor "north" and the game "north" are not the same.)>>Note:>The camera angle is based on the angle between the camera and the target. But if the camera and the target are exactly in the same horizontal position (but vertically anywhere), then this angle is indeterminable. Type 1000 both in MainParameter and Additional fields if you want to check if this situation is just true.

RTYPE2_COLD:$0001; Used with Parameters=PARAM_ACTUAL_CAM command, if you want to check if it is a cold room.

RTYPE2_DAMAGE:$0002; Used with Parameters=PARAM_ACTUAL_CAM command, if you want to check if it is a damage room.

RTYPE2_MIST:$0004; Used with Parameters=PARAM_ACTUAL_CAM command, if you want to check if it is a mist room.

RTYPE2_OUTSIDE:$0008; Used with Parameters=PARAM_ACTUAL_CAM command, if you want to check if it is an outside room.

RTYPE2_QUICKSAND:$0010; Used with Parameters=PARAM_ACTUAL_CAM command, if you want to check if it is a quicksand room.

RTYPE2_RAIN:$0020; Used with Parameters=PARAM_ACTUAL_CAM command, if you want to check if it is a rain room.

RTYPE2_REFLEX:$0040; Used with Parameters=PARAM_ACTUAL_CAM command, if you want to check if it is a water reflection room.

RTYPE2_SNOW:$0080; Used with Parameters=PARAM_ACTUAL_CAM command, if you want to check if it is a snow room.

RTYPE2_WATER:$0100; Used with Parameters=PARAM_ACTUAL_CAM command, if you want to check if it is a water room.

RTYPE2_NON_LENS:$0200; Used with Parameters=PARAM_ACTUAL_CAM command, if you want to check if it is a non-lens flare (NL) room.

RTYPE2_HORIZON:$0400; Used with Parameters=PARAM_ACTUAL_CAM command, if you want to check if this room has at least one invisible (not transparent!) texture tile placed.

RTYPE2_NON:$0800; Used with Parameters=PARAM_ACTUAL_CAM command. Add this value to other RTYPE2 flags if you want to check if they are NOT true.

PARAM_SWITCH_SEQUENCE: 8 ;Used with Parameters command.>You need this in F600 triggers, to establish the (maximum five) switches of a switch sequence.>>Syntax: Parameters=PARAM_SWITCH_SEQUENCE, IdParamList, Series, AnimSwitchOn, AnimSwitchToOff, Switch1, Switch2, Switch3, Switch4, Switch5>>IdParamList field>----------------->This is a progressive number to identify this "Parameters=PARAM_SWITCH_SEQUENCE" command script in trigger window of ngle.>You'll type 1, for your first PARAM_SWITCH_SEQUENCE command, 2 for second etc.>>Series field>------------>The sequences with the same switches must be linked to each other with this Series field.>I mean, for example, if you have two sequences for switches with object ID 152, 159, 161, then:>>- The first sequence of these switches, having Parameters=PARAM_SWITCH_SEQUENCE ID 1, is for 152, 159, 161 switch order.>- The second sequence of these switches, having Parameters=PARAM_SWITCH_SEQUENCE ID 2, is for 152, 161, 159 switch order.>>Now both the sequences have the same switches, so they are the parts of the same series.>The number you type here can be:>>0 - if it is the first sequence of the series>1 - if it is (one of) the middle sequence(s) of the series>2 - if it is the last sequence of the series>3 - if it is the only one sequence of the series>>Important!>The first sequence always has Sequence ID1, the second sequence always has Sequence ID2 etc.>>For example:>>Sequence ID 1, Series ID 0>Sequence ID 2, Series ID 1>Sequence ID 3, Series ID 2>Sequence ID 4, Series ID 3>Sequence ID 5, Series ID 0>Sequence ID 6, Series ID 1>Sequence ID 7, Series ID 1>Sequence ID 8, Series ID 2>Sequence ID 9, Series ID 3>Sequence ID 10, Series ID 0>Sequence ID 11, Series ID 2>Sequence ID 12, Series ID 0>Sequence ID 13, Series ID 2>>The first series has three sequences (Sequence 1, 2, 3).>The second series has one sequence (Sequence 4).>The third series has four sequences (Sequence 5, 6, 7, 8).>The fourth series has one sequence (Sequence 9).>The fifth series has two sequences (Sequence 10, 11).>The sixth series has two sequences (Sequence 12, 13).>>AnimSwitchOn field>------------------>Type an animation ID number of the switch type of the sequence here (from WADMerger Animation Editor).>This is the ID of the one-framed ("frozen") animation when the switch is on.>>AnimSwitchToOff field>--------------------->Type an animation ID number of that switch type here (from WADMerger Animation Editor).>This is the ID of the animation when the switch is moving back to off position.>>Switch1 field>------------->Type here the object ID of the first switch that should be used.>>Switch2 field>------------->Type here the object ID of the second switch that should be used.>>Switch3 field>------------->Type here the object ID of the third switch that should be used.>>Type IGNORE (-1) if there is no third switch, there are only two switches in the setup.>>Switch4 field>------------->Type here the object ID of the fourth switch that should be used.>>Type IGNORE (-1) if there is no fourth switch, there are maximum three switches in the setup.>>Switch5 field>------------->Type here the object ID of the fifth switch that should be used.>>Type IGNORE (-1) if there is no fifth switch, there are maximum four switches in the setup.><END>>>>>>>>>>>>>>>>>>>>